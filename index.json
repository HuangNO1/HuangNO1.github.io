[{"categories":["C/C++"],"content":"前言 大一自己寫 C++ 時碰到的問題，一直沒發表文章，現在趁有空寫一下。 ","date":"2020-08-07","objectID":"/about_c-_class_virtual_function/:1:0","tags":["C++","Class","Virtual","Function"],"title":"C++ - 關於多態中的虛函數","uri":"/about_c-_class_virtual_function/"},{"categories":["C/C++"],"content":"關於多態與虛函數 我的理解是多態就是一個類（class）演伸出多種物件（Object），父類相當於模板藍圖的功能。 我們先看一下虛函數嘴臉長怎樣： 在下面的例子中是一個 Base Class（基類、父類），如果函數前面宣告有添加 virtual 就是虛函數。 class Shape { public: virtual string toString() const; virtual double getArea() const; } 下面是一個 Circle 子類（superclass）（超生類、派生類），引入 Circle 的 getArea() 和 toString() 是虛函數，我們現在是在子類中重寫（重定義）類的虛構函數（此時你可以將父類的虛構函數想像成模板）。 class Circle : public Shape { private: double radius; public: Circle(); Circle(double); double getRadius() const; void setRadius(double); double getArea() const; string toString() const; } 實際當我們在使用虛構函數時，是把它當作跳板，去自動便是哪個函式是哪個函式，e.g. 有多種圖形（園、三角），每種圖形都有面積，虛構函數是當你在使用引用或是指針 (Pointer) 指向基類時，它能根據類自動辨識是哪個圖形（很抽象）。 舉個例子，下面的 Code 引用上面例子的 Shape 類，在下面的 printShape() 傳入的 Shape 類型參數是一個子類繼承父類 Shape 的物件（對象），因為 Circle 或是 Triangle 都是繼承自 Shape 的類，所以當 Circle 和 Triangle 傳入該函數時，你不用特別指定是哪個子類中的 getArea() 函數，會自動判定是哪個子類的物件方法。 void printShape(const Shape \u0026s, double \u0026total) { total += s.getArea(); cout \u003c\u003c s.getArea() \u003c\u003c endl; } ","date":"2020-08-07","objectID":"/about_c-_class_virtual_function/:2:0","tags":["C++","Class","Virtual","Function"],"title":"C++ - 關於多態中的虛函數","uri":"/about_c-_class_virtual_function/"},{"categories":["LaTeX"],"content":"前言 紀錄一下我在 ArchLinux 上配置 LaTeX 的過程。 ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:1:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["LaTeX"],"content":"安裝環境 你可以直接安裝集合包，texlive-most 包含很多 Tex Live 應用，但是這樣很佔空間，要安裝 2GB 的硬碟空間，所以你也可以選擇自己想要裝的部份，其中 texlive-core 是必裝的。texlive-langchinese 是中文宏包 CTeX，讓 LaTeX 支持中文。 sudo pacman -S texlive-most # 安裝約 12 個包 sudo pacman -S texlive-core # 只裝核心 sudo pacman -S texlive-langchinese # 安裝中文支持 ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:2:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["LaTeX"],"content":"測試安裝 進入特定資料夾，輸入下面兩行指令測試是否安裝成功， tex '\\empty Hello world!\\bye' 會生成 texput.dvi 和 texput.log。 pdftex '\\empty Hello world!\\bye' 會生成 texput.pdf。 tex '\\empty Hello world!\\bye' pdftex '\\empty Hello world!\\bye' ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:3:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["LaTeX"],"content":"VScode 配置 先安裝好 LaTeX Workshop 這擴充套件。 LaTeX Workshoplatex_workshop.png \" LaTeX Workshop 設定 接著按下 ctrl + , 進入 VScode 的使用者設置，並點擊右上角的設定文件（JSON），添加下面的設定： 下面設定需要修改的地方是要找到 xelatex、pdflatex、bibtex 裝在哪裡，並替換下面 latex-workshop.latex.tools 中每一項的 command，輸入以下指令可以找到位置： where xelatex # 輸出 /usr/bin/xelatex # 依此類推 跟在 Windows 上的設定差在 command，改成相對應的路徑。 設定 JSON： { // ... \"latex-workshop.latex.recipes\": [ { \"name\": \"xelatex\", \"tools\": [ \"xelatex\" ] }, { \"name\": \"pdflatex\", \"tools\": [ \"pdflatex\" ] }, { \"name\": \"xelatex-\u003ebibtex-\u003exelatex*2\", \"tools\": [ \"xelatex\", \"bibtex\", \"xelatex\", \"xelatex\" ] }, { \"name\": \"pdflatex-\u003ebibtex-\u003epdflatex*2\", \"tools\": [ \"pdflatex\", \"bibtex\", \"pdflatex\", \"pdflatex\" ] } ], \"latex-workshop.latex.tools\": [ { \"name\": \"xelatex\", \"command\": \"/usr/bin/xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-shell-escape\", \"%DOC%.tex\" ] }, { \"name\": \"pdflatex\", \"command\": \"/usr/bin/pdflatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] }, { \"name\": \"bibtex\", \"command\": \"/usr/bin/bibtex\", \"args\": [ \"%DOCFILE%\" ] } ], } 這邊主要使用兩個指令：xelatex 及 bibtex，平常都是使用 xelatex 來編譯，只有寫某些文章需要編譯 reference 時才會用到 bibtex。 為了方便何時該用哪種，上述 config 的 recipes 便派上用場，可以看到日常使用的部分我給此 recipe 取名 ”hw”，如果要編論文而需要 reference ，則會採用 ”thesis”，它會依序執行xelatex → bibtex → xelatex → xelatex，這是 LaTeX 中為了正確編出 reference 的用法。 ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:4:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["LaTeX"],"content":"Hello World 下面是一個我擷取我之前寫的報告作為簡單例子，有我經常用的設定。 \\documentclass[12pt, a4paper]{report} \\usepackage{ctex} % 中文的宏包 \\usepackage{indentfirst} \\usepackage{graphicx} % 插入圖片的宏包 \\usepackage{float} % 設置圖片浮動位置的宏包 \\usepackage{subfigure} % 插入多圖時用子圖顯示宏包 \\usepackage{listings} % 代碼塊宏包 \\usepackage{color} % 代碼高亮 \\usepackage[colorlinks,linkcolor=blue]{hyperref} % URL 包 \\usepackage[pdf]{graphviz} \\usepackage{alphalph} \\renewcommand*{\\thesubfigure}{(\\arabic{subfigure})} \\definecolor{dkgreen}{rgb}{0,0.6,0} \\definecolor{gray}{rgb}{0.5,0.5,0.5} \\definecolor{mauve}{rgb}{0.58,0,0.82} \\lstset{ % %language=Octave, % the language of the code basicstyle=\\scriptsize\\Hack, % the size of the fonts that are used for the code numbers=none, % where to put the line-numbers numberstyle=\\tiny\\color{gray}, % the style that is used for the line-numbers stepnumber=2, % the step between two line-numbers. If it's 1, each line % will be numbered numbersep=3pt, % how far the line-numbers are from the code backgroundcolor=\\color{white}, % choose the background color. You must add \\usepackage{color} showspaces=false, % show spaces adding particular underscores showstringspaces=false, % underline spaces within strings showtabs=false, % show tabs within strings adding particular underscores frame=single, % adds a frame around the code rulecolor=\\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here)) tabsize=2, % sets default tabsize to 2 spaces captionpos=b, % sets the caption-position to bottom breaklines=true, % sets automatic line breaking breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace title=\\lstname, % show the filename of files included with \\lstinputlisting; % also try caption instead of title keywordstyle=\\color{blue}, % keyword style commentstyle=\\color{dkgreen}, % comment style stringstyle=\\color{mauve}, % string literal style escapeinside={\\%*}{*}, % if you want to add LaTeX within your code morekeywords={*,...} % if you want to add more keywords to the set } \\setCJKmainfont{Noto Serif CJK TC} % 主要字體 Noto Serif \\newfontfamily\\Hack{Hack} % 代碼字體 \\author{Huang Po-Hsun} \\date{\\today} \\title{數據庫系統 SSD7 實驗報告} \\begin{document} \\maketitle \\tableofcontents \\part{實驗一、數據庫與表的基本操作} \\section{實驗目的} \\begin{itemize} \\item 熟练掌握一种DBMS的使用方法，完成数据库的创建、删除和连接；数据表的建立、删除；表结构的修改。 \\item 加深对表的实体完整性、参照完整性和用户自定义完整性的理解。 \\end{itemize} \\end{document} ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:5:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["LaTeX"],"content":"畫面 這是實際寫 LaTeX 的畫面。 編寫畫面preview.png \" 編寫畫面 ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:6:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["LaTeX"],"content":"Reference TeX Live (简体中文) - ArchWiki LaTeX Workshop – 在VSCode中編輯及編譯LaTeX ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:7:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["Markdown"],"content":"前言 Markdown 我認為是非常好的語言，我每次寫 Blog 或是寫項目、作筆記，Markdown 是首選，LaTeX 比較適合拿來寫報告或是論文。我就在這篇寫一下 Markdown 基礎語法，也就是平常經常用到的語法，其實當初學 Markdown 只花了一小時，後面慢慢寫多就習慣了。 寫 Markdown 的工具： 我推薦下面幾個： Typora：跨平台的 Markdown 編輯器，簡直是利器。 Visual Studio Code：使用 VScode 也可以寫 Markdown，安裝 Markdown All in One 和 Markdown Preview Enhanced 延伸模組，就能夠舒服地寫筆記或文章。 HackMD：線上共筆平台，使用 Markdown，大家在共同寫文檔時可以使用這平台 ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:1:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"文本編寫標準 中文文案排版指北 [简体中文 ][繁体中文 ] ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:2:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"區塊元素 ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"標題 h1 - h6，h1 有兩種寫法。第一種是下一行添加 ===，第二種就是加上 #。 h1 標題 === # h1 標題 ## h2 標題 ### h3 標題 #### h4 標題 ##### h5 標題 ###### h6 標題 ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:1","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"註解 跟 HTML 一樣的用法使用 \u003c!-- --\u003e。 \u003c!-- 我是註解 --\u003e ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:2","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"引言 Markdown使用email形式的區塊引言，使用 \u003e 的方式添加引言，\u003e \u003e 是二級引言，引言內也可以使用其他 MD 語法。P.S. 二級引言我平時寫文章或筆記都用不到。 \u003e This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, \u003e consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. \u003e Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. \u003e \u003e Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse \u003e \u003e id sem consectetuer libero luctus adipiscing. \u003e ## This is a header. \u003e \u003e 1. This is the first list item. \u003e 2. This is the second list item. 輸出如下： 因為上面的二級標題會影響我這篇文章的標題，我這 Blog 是使用 Markdown 寫的，所以就沒有加到輸出效果。 This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. This is the first list item. This is the second list item. ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:3","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"清單 List 無序清單 使用 *、+、- 皆可輸出無序清單，但是我比較長使用 -，因為 * 和 + 需要按住 shift 鍵。清單可以多層，二層清單是在下一行空兩格繼續寫清單。 * Red * Green * Blue + Red + Green + Blue - Red - Green - Blue \u003c!-- 二層清單 --\u003e * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies 輸出如下： Red Green Blue Red Green Blue Red Green Blue Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies 有序清單 使用數字接著一個英文句點： 1. Bird 2. McHale 3. Parish 輸出如下： Bird McHale Parish 注意 你在清單標記上使用的數字並不會影響輸出的HTML結果。 e.g. 下面的 Code： 1. Bird 1. McHale 1. Parish 3. Bird 1. McHale 8. Parish 輸出： Bird McHale Parish Bird McHale Parish 清單項目可以包含多個段落，每個項目下的段落都必須縮排 4 個空白或是一個 Tab： 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. 當然，項目清單很可能會不小心產生，像是下面這樣的寫法： 1986. What a great season. 換句話說，也就是在行首出現數字－句點－空白，要避免這樣的狀況，你可以在句點前面加上反斜線。 1986\\. What a great season. ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:4","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"程式碼區塊 縮排 4 個空白或是 1 個 Tab 就可以簡單達到 Code 區塊。 print('Hello') 輸出如下： print('Hello') 但是我不建議這樣的寫法，正確的寫法應該如下： ```python print(‘Hello’) ``` 輸出結果如下： print('Hello') 使用 ``` 將 Code 區塊包起來，並在開頭寫明是哪種語言，以方便語法高亮，行內 Code 區塊使用如下： 我是 `行內 Code` 喔！ 輸出如下： 我是 行內 Code 喔！ ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:5","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"分隔線 你可以在一行中用三個或以上的星號、減號、底線來建立一個分隔線，行內不能有其他東西。你也可以在星號中間插入空白。下面每種寫法都可以建立分隔線： * * * *** ***** - - - --------------------------------------- 輸出如下： P.S 這輸出效果有點模糊呀 (;3;) ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:6","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"區段元素 ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:4:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"連結 Markdown支援兩種形式的連結語法：行內和參考兩種形式。 不管是哪一種，連結的文字都是用 [方括號] 來標記。 然而這裡我就只使用行內的形式，所以只需要會行內就好，但你如果喜歡參考的形式也是可以。 行內 你可以使用 [Google](https://www.google.com) 搜索引擎 參考 你可以使用 [Google][] 搜索引擎 [Google]: http://google.com/ ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:4:1","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"強調 斜體與粗體，我都使用 * 和 **，看個人習慣使用哪個符號。 *single asterisks* _single underscores_ **double asterisks** __double underscores__ 輸出如下： single asterisks single underscores double asterisks double underscores ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:4:2","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"圖片 一個驚嘆號 !。 接著一個方括號，裡面放上圖片的替代文字。 接著一個普通括號，裡面放上圖片的網址，最後還可以用引號包住並加上選擇性的’title’文字。 ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg \"Optional title\") ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:4:3","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"跳脫字元 Markdown 可以利用反斜線來插入一些在語法中有其他意義的符號，例如：如果你想要用星號加在文字旁邊的方式來做出強調效果（但不用 \u003cem\u003e 標籤），你可以在星號的前面加上反斜線： \\*literal asterisks\\* Markdown支援在下面這些符號前面加上反斜線來幫助插入普通的符號： \\ 反斜線 ` 反引號 * 星號 _ 底線 {} 大括號 [] 方括號 () 括號 # 井字號 + 加號 - 減號 . 英文句點 ! 驚嘆號 ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:5:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"Reference Markdown 語法說明 ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:6:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["前端"],"content":"關於我遇到的問題 這是我在寫小 DEMO 發現的，關於 JS 的賦值問題，這裡涉及到了 Pointer。 下面是我用簡單的 Code 描述我遇到的問題，object 是一個 Object Array，然後傳入函數進行局域變量賦值。 let object = [ { name: \"John\", age: 18 }, { name: \"Amy\", age: 20 }, ] function Test(object) { let newOne = object; for (let i = 0; i \u003c newOne.length; i++) { newOne[i].name = \"Rose\"; } } Test(object) console.log(object) 結果輸出如下： // object [ { name: \"Rose\", age: 18 }, { name: \"Rose\", age: 20 }, ] 從這個輸出結果來看，我們可以判定，這個函式修改 newOne 這個局部變量時，也修改到了 object。 我網上爬了文，大致知道這是 JS 的一個像是語法 Bug 的問題，賦值給 newOne 時其實是給了指針位置，所以導致修改 newOne 時也修改到了 object。 所以要改寫成下面的寫法： 利用聲明一個臨時局部變量然後賦值，再 Push 進 Array。 let object = [ { name: \"John\", age: 18 }, { name: \"Amy\", age: 20 }, ] function Test(object) { let newOne = []; for (let i = 0; i \u003c object.length; i++) { let temp = { name: \"Rose\", age: object[i].age } newOne.push(temp); } } Test(object) console.log(object) 輸出結果： // object [ { name: \"John\", age: 18 }, { name: \"Amy\", age: 20 }, ] ","date":"2020-08-06","objectID":"/js_pointer_object_array_variable_assignment/:1:0","tags":["JS","前端","Pointer","Variable","Object","Assignment","Array"],"title":"JS - 賦值問題","uri":"/js_pointer_object_array_variable_assignment/"},{"categories":["前端"],"content":"前言 在這篇文章筆記紀錄一下 JS 的 Array 屬性。 ","date":"2020-08-06","objectID":"/js_array_prototype/:1:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"forEach() forEach 是對每一項的操作，會影響原來的 array，不會有回傳值，即使強制寫 return，也會是空值，例子如下。 // JS forEach 與 map // forEach 是對每一項的操作，會影響原來的 array let arr = [1, 2, 3, 4, 5, 6] // 對數組直接進行循環，相當於 for，沒有返回值 // result 不會有返回值 即使寫了 return 也是 undefined let result = arr.forEach((item, index, arr) =\u003e { console.log(item) console.log(index) console.log(arr) return item }) console.log(result) ","date":"2020-08-06","objectID":"/js_array_prototype/:2:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"map() map 則是不會影響原來的 array 值，而是生成新的值返回給新的數組。對 Array 每一項進行加工，加工完成之後返回一個新的數組。 // map 對數組每一項進行加工，加工完成之後返回一個新的數組 arr.map((item, index, arr) =\u003e { let str = index + item + index return str; }) console.log(arr) ","date":"2020-08-06","objectID":"/js_array_prototype/:3:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"filter() 顧名思義，過濾，filter 將想要的內容進行篩選，不想要的過濾，最終得到想要的內容。 // filter 過濾，將想要的內容進行篩選，不想要的過濾，最終得到想要的內容 let result2 = arr.filter((item, index) =\u003e { // 通過返回 true 或是 false 進行選擇 // true 是要，false 是不要 if (item % 2 === 0) { return true } else { return false } }) console.log(result2) ","date":"2020-08-06","objectID":"/js_array_prototype/:4:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"reduce() reduce 是對整個 Array 進行整合， // reduce 是對整個數組進行整合 // 比如你要做一個將術組裡所有的數字進行相加 // 將數組每一項內容整合後，返回一個內容 let arr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9] let arr4 = arr2.reduce((pre, next, index) =\u003e { console.log(pre) console.log(next) console.log(index) return pre + next }, 0) // 這裡尾部的 0 是初始值，因為弟一個參數 沒有 pre console.log(arr4) 使用箭頭函數進行整合。 const array1 = [1, 2, 3, 4]; const reducer = (accumulator, currentValue) =\u003e accumulator + currentValue; // 1 + 2 + 3 + 4 console.log(array1.reduce(reducer)); // expected output: 10 // 5 + 1 + 2 + 3 + 4 console.log(array1.reduce(reducer, 5)); // expected output: 15 ","date":"2020-08-06","objectID":"/js_array_prototype/:5:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"For 循環 for…in…主要用於遍歷對象（Object），不適用遍歷數組。 for…of…可以用來遍歷 Array，類數組對象，字符串，set/map, generator。 // for...in...主要用於遍歷對象，不適用遍歷數組 // for...of...可以用來遍歷數組，類數組對象，字符串，set/map, generator // for(key of obj) 裡面的是每一項 let obj = { name: \"Huang\", type: \"handsome\", content: \"front end\" } for(key in obj) { console.log(\"key: \" + key + \", value: \" + obj[key]) } // 循環每一項 for (let item of arr2) { console.log(item) } ","date":"2020-08-06","objectID":"/js_array_prototype/:6:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"Reference Array.prototype.reduce() - MDN ","date":"2020-08-06","objectID":"/js_array_prototype/:7:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"前言 因為我前段時間學了 React，我會在這邊文章紀錄我學到的內容。 ","date":"2020-08-05","objectID":"/react_learn_note/:1:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"建立一個 Hello World 在終端機輸入下面的指令，會在該目錄下生成一個名為 my-app 的 React 應用目錄。 註：npx 是 npm 5.2+ 或更高版本附帶的包運行器工具。 npx npx create-react-app my-app npm npm init react-app my-app Yarn Yarn 0.25+ 才能使用 yarn create \u003cstarter-kit-package\u003e yarn create react-app my-app ","date":"2020-08-05","objectID":"/react_learn_note/:2:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"Project 結構 my-app ├── README.md ├── node_modules ├── package.json ├── .gitignore ├── public │ ├── favicon.ico │ ├── index.html │ └── manifest.json └── src ├── App.css ├── App.js ├── App.test.js ├── index.css ├── index.js ├── logo.svg ├── serviceWorker.js └── setupTests.js 這部份跟 Vue-cli 蠻相似的，只是在目錄結構上不如 Vue-cli。 檔案或文件 用途 node_modules/ 依賴 package.json 包管理文件 public/ 公共資源目錄 src/ 源碼 src/index.js 根頁面 我這裡是建議 src/ 改成跟 Vue-cli 初始化時相同的結構。可以自己定義想要怎麼樣的結構，所以不一定要像我下面寫的一樣。 my-app ├── README.md ├── node_modules ├── package.json ├── .gitignore ├── public │ ├── favicon.ico │ ├── index.html │ └── manifest.json └── src ├── components │ └── App │ ├── App.css │ ├── App.js │ └── App.test.js ├── index.css ├── index.js ├── router │ └── index.js ├── store │ └── index.js ├── static │ ├── css │ ├── img │ │ └── logo.svg │ └── js ├── serviceWorker.js ├── setupTests.js └── views ├── Home │ ├── Home.css │ └── Home.js └── About ├── About.css └── About.js ","date":"2020-08-05","objectID":"/react_learn_note/:3:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"指令 下面兩個之一的指令可以運行項目。 npm start yarn start 下面是打包指令 npm run build yarn build ","date":"2020-08-05","objectID":"/react_learn_note/:4:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"JSX ","date":"2020-08-05","objectID":"/react_learn_note/:5:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"語法 JSX 就是一種可以用 JS 寫 HTML 的語法，最後編譯會轉成 HTML，光是可以用 JS 寫網頁就可以使開發上更加靈活。 下面是一個 JS 的普通對象，包括一開始初始化項目的 App.js 也是對象。可以改造成下面例子的樣子。 對象與組件是不同的東西，組件命名開頭必須是大寫，對象則不用，element = \u003ch1\u003e你好，世界！\u003c/h1\u003e; 可以想像成是變量與值，element 被賦值組件值。 import React, { Children } from \"react\"; import ReactDOM from \"react-dom\"; import \"./index.css\"; import App from \"./App\"; const element = \u003ch1\u003e你好，世界！\u003c/h1\u003e; // \u003cApp /\u003e 普通對象 let root = document.getElementById(\"root\"); ReactDOM.render(element, root); ","date":"2020-08-05","objectID":"/react_learn_note/:5:1","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"簡單的 Clock 實例 這例子是使用間隔函數不斷重新渲染頁面，但是因為根頁面渲染被限制住了，所以不適合。 註：在選取元素 ID 不一定要用 document.getElementById(\"root\") 也可以使用 document.querySelector('#root') 方式操作 DOM。 function clock() { let time = new Date().toLocaleTimeString(); let element = \u003ch1\u003eCurrent Time: { time }\u003c/h1\u003e; let root = document.querySelector('#root') ReactDOM.render(element, root) } clock(); // 間隔函數 setInterval(clock, 1000); 下面的例子是上面的改版，是函數式組件。 註：組件名稱都必須是開頭大寫，不然無法被 JSX 語法識別。 // react 函數式組件 // 組件開頭必須大寫 function Clock(props) { return ( \u003ch1\u003eCurrent Time: { props.date.toLocaleTimeString() }\u003c/h1\u003e ); } function run() { // date 傳參 ReactDOM.render( \u003cClock date={ new Date() } /\u003e, document.querySelector('#root') ) } setInterval(run, 1000); ","date":"2020-08-05","objectID":"/react_learn_note/:5:2","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"Style 寫 Style 對象時參數是駝峰命名法，當然也可以使用像是 \"background-img\": \"url(https...)\" 的方法表示樣式參數，雖然可以使用原來的命名，但是不建議用這方法，因為 Code 的規範。 因為 class 在 JS 中表示類，是 Keyword，所以要改用 className 表示 HTML 元素中的類樣式，兩者是不同的概念。 在 JSX 語法中要寫註解的話，分成 HTML 使用 {/* */} 這方法，因為 {} 是放 JS 語法的地方，JS 中就直接 //。 // 駝峰命名 // style 中如果存在多個單字的屬性組合，第二個單字開始，首字母大寫。 // 可以不首字母大寫，但要換寫法 let exampleStyle = { background: \"skyblue\", borderBottom: \"1px solid red\", // 不用首字母大寫的方法 e.g. // \"background-img\": \"url(https...)\" } let element = ( \u003cdiv\u003e \u003ch1 style={exampleStyle}\u003eHello World\u003c/h1\u003e \u003c/div\u003e ) // class 在 Js 中是關鍵字，所以要改成 className // className 和 style 等屬性不能是 string，必須是對象參數 // 不能有多個 className 或是多個 style，會被自動刪掉剩一個 // className 可以用 string 相加的方式 let classStr = \"abc\" let element1 = ( \u003cdiv\u003e \u003ch1 className={\"cba \" + classStr}\u003eHello World\u003c/h1\u003e \u003c/div\u003e ) // react 中 className array 無法像 Vue 一樣可以自動拆解 // 所以要加上 join 去做間隔 let classArray = ['abc', 'cba'].join(\" \"); let elementArrayClass = ( \u003cdiv\u003e {/* 在 HTML 寫註釋 */} \u003ch1 className={classArray}\u003eHello World\u003c/h1\u003e \u003c/div\u003e // 在 JS 寫註釋 ) ReactDOM.render( element1, document.querySelector('#root') ) ","date":"2020-08-05","objectID":"/react_learn_note/:5:3","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"組件 命名開頭都必須是大寫。 函數式組件 下面是前面簡單 Clock 實例的函數式組件，傳參進行渲染。 函數式組件是靜態組件，頂多傳參數。 函數式組件 stateless 無生命週期。 function Clock(props) { return ( \u003ch1\u003eCurrent Time: { props.date.toLocaleTimeString() }\u003c/h1\u003e ); } 類組件 下面是最簡單的類組件 類組件可以定義方法。 類組件 stateful 有生命週期。 類組件中可以在包含組件 -\u003e 複合組件。 // 類組件 - 可以定義方法 // 有事件或是動態的 使用類組件：e.g. 點擊事件 // 函數式組件是靜態組件，頂多傳參數 // 函數式組件 stateless 無生命週期 // 類組件 stateful 有生命週期 // 類組件中可以在包含組件 -\u003e 複合組件 class HelloWorld extends React.Component { render(){ console.log(this) return ( \u003cdiv\u003e \u003ch1\u003e類組件 Hello World\u003c/h1\u003e {/* 類組件傳參 */} {/* \u003ch2\u003ehello: {this.props.name}\u003c/h2\u003e */} \u003c/div\u003e ) } } ReactDOM.render( \u003cHelloWorld /\u003e, document.querySelector('#root') ) 類組件實現簡單 Clock 實例 React State 相當於 Vue 的 Data。** React 類組件中要修改 State 的話，不能直接修改，要使用 this.setState() 方法進行修改。 constructor() 是構造函數，render() 是渲染函數。 super() 是繼承父類的方法，props 可以用來傳參。 下面的例子只是簡單實現的 Clock 顯示，這裡只是舉個例子讓你了解怎麼使用類組件。下面例子最尾部的註解是因為一開始我們沒有使用生命周期函數 componentDidMount() 去做時間的更新，後面因為用到了生命周期函數，所以要將原本的註解掉，算是錯誤示範。 // React State 相當於 Vue 的 Data // 用類組件實現 class ClockClass extends React.Component { // 構造函數 constructor(props) { super(props) // 狀態 (數據) -\u003e View this.state = { time: new Date().toLocaleTimeString() } } render() { // this.state.time = new Date().toLocaleTimeString(); return ( \u003cdiv\u003e \u003ch1\u003e{this.state.time}\u003c/h1\u003e \u003c/div\u003e ) } // 生命周期函數 // 組件渲染完成時調用的函數 componentDidMount() { setInterval(() =\u003e { // 錯誤的改變方式 // this.state.time = new Date().toLocaleTimeString(); // 正確的修改，使用 setState // 切勿直接修改 state 數據，直接 state 重新渲染內容，需使用 setState // setState 是異步 // 通過 this.setState 修改完數據後，並不會立即修改 DOM 裡面的內容 // react 會在這個修改函數內容所有設置改變後，統一對比虛擬 DOM 對象，然後再統一修改，提升性能 this.setState({ time: new Date().toLocaleTimeString() }) }, 1000) } } ReactDOM.render( \u003cClockClass /\u003e, document.querySelector('#root') ) // 不推薦的方法，因為跟組件 Dom 渲染綁在一起 // setInterval(() =\u003e { // ReactDOM.render( // \u003cClockClass /\u003e, // document.querySelector('#root') // ) // }, 1000) 類組件方法綁定 類的方法需要進行綁定 this 才能進行使用，也可以使用箭頭函數，箭頭函數直接就是指向父類的 this。 class Tab extends React.Component { constructor(props) { super(props) // 設置狀態和數據 this.state = { isActive: \"\", strClass: \"\" } this.clickEvent = this.clickEvent.bind(this) } clickEvent() { console.log(\"click event\") } render() { return ( \u003cdiv\u003e \u003cbutton onClick={this.clickEvent}\u003econtent 1\u003c/button\u003e \u003cbutton\u003econtent 2\u003c/button\u003e \u003cdiv className=\"content active\"\u003e \u003ch1\u003econtent 1\u003c/h1\u003e \u003c/div\u003e \u003cdiv className=\"content\"\u003e \u003ch1\u003econtent 2\u003c/h1\u003e \u003c/div\u003e \u003c/div\u003e ) } } ","date":"2020-08-05","objectID":"/react_learn_note/:5:4","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"組件傳值 父傳子 在 JSX 中，只能父傳子組件數據，單向流動，不能子傳父。 注意：props 可以傳遞函數，props 可以傳遞父函數的元素，就可以去修改父元素的 state，從而達到子組件傳遞數據給父元素。 // Props // 父傳子組件數據，單向流動，不能子傳父 // props 可以設置默認值 // 注意：props 可以傳遞函數，props 可以傳遞父函數的元素，就可以去修改父元素的 state，從而達到傳遞數據給父元素 // 在父元素中使用 state 去控制子元素 props 的從而達到父元素數據傳遞給子元素 class ParentCom extends React.Component { constructor(props) { super(props) this.state = { isAction: true } // 綁定事件 this.changeShow = this.changeShow.bind(this) } render() { return ( \u003cdiv\u003e \u003cbutton onClick={this.changeShow}\u003e控制子元素顯示\u003c/button\u003e \u003cChildrenCom isAction={this.state.isAction}/\u003e \u003c/div\u003e ) } changeShow() { this.setState({ isAction: !this.state.isAction }) } } class ChildrenCom extends React.Component { constructor(props) { super(props) } render() { let strClass = null; if(this.props.isAction) { strClass = 'active' } else { strClass = '' } return ( \u003cdiv className={\"content \" + strClass}\u003e \u003ch1\u003e我是子元素\u003c/h1\u003e \u003c/div\u003e ) } } ReactDOM.render( \u003cParentCom /\u003e, document.querySelector('#root') ) 子傳父 調用父元素的函數從而操作子元素的數據，從而實現 子 -\u003e 父。 // 子傳父 // 調用父元素的函數從而操作子元素的數據，從而實現 子 -\u003e 父 class ParentCom2 extends React.Component { constructor(props) { super(props) this.state = { childData: null } } render() { return ( \u003cdiv\u003e \u003ch1\u003e子傳父的數據：{this.state.childData}\u003c/h1\u003e {/* 傳遞函式給子組件 */} \u003cChildrenCom2 setChildData={this.setChildData}/\u003e \u003c/div\u003e ) } setChildData = (data) =\u003e { this.setState({ childData: data }) } } class ChildrenCom2 extends React.Component { constructor(props) { super(props) this.state = { msg: \"hello\" } } render() { return ( \u003cdiv\u003e \u003cbutton onClick={this.sendData}\u003e傳遞 hello 給父元素\u003c/button\u003e {/* 更簡單的方法 */} \u003cbutton onClick={ () =\u003e {this.props.setChildData('直接傳')}}\u003e傳遞 hello 給父元素\u003c/button\u003e \u003c/div\u003e ) } // 搞成箭頭函數 sendData = () =\u003e { console.log(this.state.msg) // 用 props 拿到父組件的函數 // 將子元素數據傳遞給父元素 this.props.setChildData(this.state.msg) } } ReactDOM.render( \u003cParentCom2 /\u003e, document.querySelector('#root') ) ","date":"2020-08-05","objectID":"/react_learn_note/:5:5","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"Event 事件綁定 onClick 用來綁定事件，在綁定的時候不能像 Vue 中 @click=\"...\" 一樣使用 String，要使用 {} 傳入一個函數。下面的事件使用的箭頭函數，這樣就不需要在構造函數寫綁定。 // React event // 綁定事件使用駝峰命名法 // {} 傳入一個函數，不是 String // 原生 js 阻止默認行為時，可以直接返回 return false // react 中，阻止默認必須使用 e.preventDefault(); class ClickCom extends React.Component { render() { return ( \u003cdiv\u003e \u003cform action=\"https://www.google.com\" target=\"_blank\"\u003e \u003cbutton onClick={this.preventEvent}\u003esubmit\u003c/button\u003e \u003c/form\u003e {/* es6 箭頭函數 */} \u003cbutton onClick={(e) =\u003e { this.preventEvent1(\"msg: 123\", e); }} \u003e submit \u003c/button\u003e {/* 不使用 es6 箭頭函數傳遞多個參數的方式 */} \u003cbutton onClick={function (e) { this.preventEvent1(\"msg: 123\", e); }.bind(this)} \u003e submit \u003c/button\u003e \u003c/div\u003e ); } preventEvent = (e) =\u003e { console.log(e.preventDefault); e.preventDefault(); // js 原生寫法 // return false }; preventEvent1 = (msg, e) =\u003e { console.log(msg); // js 原生寫法 // return false }; } ReactDOM.render(\u003cClickCom /\u003e, document.querySelector(\"#root\")); ","date":"2020-08-05","objectID":"/react_learn_note/:5:6","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"條件渲染 下面是簡單的條件渲染，情況二因為可以是三元運算式，直接透過運算賦值給一個變量成一個 JSX 對象，所以在這裡沒有寫，以下面情況一的例子就是 let element = this.state.isLogin ? \u003cUserGreet/\u003e : \u003cUserLogin/\u003e 然後 return element，差別不大。 // React 條件渲染 // 1. 直接通過條件運算返回要渲染的 JSX 對象 // 2. 通過條件運算得出 JSX 對象，將對象渲染到模板 // 情況一 function UserGreet(params) { return (\u003ch1\u003ewelcome to sign in\u003c/h1\u003e) } function UserLogin(params) { return (\u003ch1\u003e請先登入\u003c/h1\u003e) } class ParentCom extends React.Component { constructor(props) { super(props) this.state = { isLogin: false } } render() { if(this.state.isLogin) { return (\u003cUserGreet/\u003e) } else { return (\u003cUserLogin/\u003e) } } } ReactDOM.render(\u003cParentCom /\u003e, document.querySelector(\"#root\")); // 情況二 // 自己類推 ","date":"2020-08-05","objectID":"/react_learn_note/:5:7","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"List 渲染（循環渲染） 下面是簡單的 List 渲染例子： arrayHTML 是 JSX 對象 Array。但是這個例子因為使用上不夠優雅靈活，所以不適合，應該要使用像是傳參動態渲染的方法。 // List 渲染 let array = [\"banana\", \"apple\", \"peach\"]; let arrayHTML = [\u003cli\u003ebanana\u003c/li\u003e, \u003cli\u003eapple\u003c/li\u003e, \u003cli\u003epeach\u003c/li\u003e] class Welcome extends React.Component { constructor(props) { super(props) } render() { return ( \u003cdiv\u003e \u003cul\u003e {array} {arrayHTML} \u003c/ul\u003e \u003c/div\u003e ) } } ReactDOM.render(\u003cWelcome /\u003e, document.querySelector(\"#root\")); 下面是更進的改造版，將一部份作為函式數組件，傳入參數可以進行渲染，相當於模板。 // 作為模板 function ListItem(props) { return ( \u003cli key={props.index}\u003e \u003ch3\u003e {props.index} : {props.data.title} \u003c/h3\u003e \u003cp\u003e{props.data.content}\u003c/p\u003e \u003c/li\u003e ); } // 有動態事件的方式 class ListItem2 extends React.Component { constructor(props) { super(props); } render() { return ( \u003cli key={this.props.index} onClick={(event) =\u003e { this.clickEvent(this.props.index, this.props.data.title, event); }} \u003e \u003ch3\u003e {this.props.index} : {this.props.data.title} \u003c/h3\u003e \u003cp\u003e{this.props.data.content}\u003c/p\u003e \u003c/li\u003e ); } clickEvent = (index, title, event) =\u003e { alert(index + \" - \" + title); }; } class Welcome extends React.Component { constructor(props) { super(props); this.state = { list: [ { title: \"NO1 111\", content: \"11111\", }, { title: \"NO2 222\", content: \"222\", }, { title: \"NO3 333\", content: \"333\", }, ], }; } render() { // 最原始方法 // let listArr = []; // for(let i = 0; i \u003c this.state.list.length; i++) { // let item = ( // \u003cul\u003e // \u003cli\u003e\u003ch3\u003e{this.state.list[i].title}\u003c/h3\u003e\u003c/li\u003e // \u003cli\u003e\u003ch5\u003e{this.state.list[i].content}\u003c/h5\u003e\u003c/li\u003e // \u003c/ul\u003e // ) // listArr.push(item); // } // 使用數組 map 方法，對每一項數據進行 JSX 的形式進行加工， // 最終得到 1 個每一項都是 JSX 對象的數組，將數組渲染到模板。 // Key 需要放入每一項中 let listArr = this.state.list.map((item, index) =\u003e { return ( // \u003cli key={index}\u003e // \u003ch3\u003e{index} : { item.title }\u003c/h3\u003e // \u003cp\u003e{ item.content }\u003c/p\u003e // \u003c/li\u003e // \u003cListItem data={item} index={index} key={index} /\u003e \u003cListItem2 data={item} index={index} key={index} /\u003e ); }); return ( \u003cdiv\u003e {/* 最原始方式 */} {/* {listArr} */} \u003cul\u003e{listArr}\u003c/ul\u003e \u003c/div\u003e ); } } ReactDOM.render(\u003cWelcome /\u003e, document.querySelector(\"#root\")); ","date":"2020-08-05","objectID":"/react_learn_note/:5:8","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"組件生命週期 組件從實例化到最終從頁面銷毀，整個過程就是生命週期，在這生命週期中，我們有許多可以調用的方法，俗稱鉤子函數。 三個狀態 Mounting 將組件插入到 DOM 中 Updating 將數據更新到 DOM 中 UnMounting 將組件移除 DOM 生命周其中的鉤子函數（方法、事件） ComponentWillMount：組件將要渲染（已過時，不能用） ComponentDidMount：組件渲染完畢 ComponentWillReceiveProps：組件將要接受 props 數據（已過時，不能用） ShouldComponentUpdate：組件接收到新的 state 或是 props，判斷是否更新，返回布爾值 ComponentWillUpdate：組件將要更新（已過時，不能用） ComponentDidUpdate：組件已經更新完畢 ComponentWillUnMount：組件將要卸載 // 可以解構 // 這樣就不用每次都寫 react.Component import { Component } from 'react' class ComLife extends Component { constructor(props) { super(props) // 調用繼承 Component 的 構造函數 this.state = { msg: \"hello world msg\" } console.log(\"constructor 構造函數\") } componentWillMount() { // 已過時 // 通常用來 ajax 請求 // 添加動畫前的類 console.log(\"ComponentWillMount 組件將要渲染\") } componentDidMount() { // 用來渲染動畫 console.log(\"ComponentDidMount 組件渲染完畢\") } componentWillReceiveProps() { // 已過時 // 用來查看 props 內容是什麼 console.log(\"ComponentWillReceiveProps 組件將要接受 props 數據\") } componentWillUpdate() { // 已過時 console.log(\"ComponentWillUpdate 組件將要更新\") } componentDidUpdate() { console.log(\"ComponentDidUpdate 組件已經更新完畢\") } componentWillUnmount() { console.log(\"ComponentWillUnMount 組件將要卸載\") } render() { console.log(\"render 渲染函數\") return ( \u003cdiv\u003e \u003ch1\u003ehello\u003c/h1\u003e \u003c/div\u003e ) } } ","date":"2020-08-05","objectID":"/react_learn_note/:5:9","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"插槽 組件中寫入內容，這些內容可以被識別和控制。React 需要自己開發支持插槽功能。 原理：組件中寫入的 HTML，可以傳入到 props 中。 註：這裡的 data-{ name } 是 HTML 中自定義屬性。e.g. 下面例子中的 data-position 和 data-index。 // 組件中寫入內容，這些內容可以被識別和控制。React 需要自己開發支持插槽功能 // 原理：組件中寫入的 HTML，可以傳入到 props 中 class ParentCom extends React.Component { constructor(props) { super(props); this.state = { arr: [1, 2, 3], }; } render() { console.log(this.props); return ( \u003cdiv\u003e \u003ch1\u003e組件插槽\u003c/h1\u003e {this.props.children} \u003cChildCom\u003e \u003ch1 data-position=\"header\"\u003e這是放置到頭部的內容\u003c/h1\u003e \u003ch1 data-position=\"main\"\u003e這是放置到主要的內容\u003c/h1\u003e \u003ch1 data-position=\"footer\"\u003e這是放置到尾部的內容\u003c/h1\u003e \u003c/ChildCom\u003e \u003c/div\u003e ); } } class ChildCom extends React.Component { render() { let headerCom, mainCom, footerCom; this.props.children.forEach((item, index) =\u003e { if (item.props[\"data-position\"] === \"header\") { headerCom = item; } else if (item.props[\"data-position\"] === \"main\") { mainCom = item; } else { footerCom = item; } }); return ( \u003cdiv\u003e \u003cdiv className=\"header\"\u003e{headerCom}\u003c/div\u003e \u003cdiv className=\"main\"\u003e{mainCom}\u003c/div\u003e \u003cdiv className=\"footer\"\u003e{footerCom}\u003c/div\u003e \u003c/div\u003e ); } } class RootCom extends React.Component { render() { return ( \u003cParentCom\u003e {/* 插槽 */} {/* 添加 data 屬性可以傳參，data- 後面接想要取的屬性名 */} \u003ch2 data-name=\"a\" data-index={this.state.arr[0]}\u003e 子組件一 \u003c/h2\u003e \u003ch2 data-name=\"b\" data-index={this.state.arr[1]}\u003e 子組件二 \u003c/h2\u003e \u003ch2 data-name=\"c\" data-index={this.state.arr[2]}\u003e 子組件三 \u003c/h2\u003e \u003c/ParentCom\u003e ); } } ReactDOM.render(\u003cRootCom /\u003e, document.querySelector(\"#root\")); ","date":"2020-08-05","objectID":"/react_learn_note/:5:10","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"React Router 路由 根據不同的路徑，顯示不同的組件(內容)，React 使用庫 react-router-dom。 ","date":"2020-08-05","objectID":"/react_learn_note/:6:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"安裝 npm install react-router-dom ","date":"2020-08-05","objectID":"/react_learn_note/:6:1","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"使用 ReactRouter 三大組件 Router：所有路由組件的根組件(底層組件)，包裏路由規則的最外層容器 Route：路由規則匹配組件，顯示當前規則對應的組件 Link：路由跳轉組件 注意：如果要精準匹配，那麼可以在 route 上設置 exact 屬性。精準匹配的意思就是完整路徑包含父路徑。 Hash 與 History 模式，Hash 就是有 ‘#’ 符號，我們使用 History。 引入 // hash 模式 // as 是取別名 // import { HashRouter as router, Link, Route } from 'react-router-dom' // History 模式 / 後端匹配使用 import { BrowserRouter as Router, Link, Route } from \"react-router-dom\"; 基本使用 \u003cLink\u003e\u003c/Link\u003e 相當於 Vue 中的 \u003croute-link\u003e\u003c/route-link\u003e，用於路由跳轉。 \u003cRouter\u003e\u003c/Router\u003e 路由配置，可以設置基本路徑（Base Path），裡面包 \u003cRoute\u003e\u003c/Route\u003e，\u003cRoute\u003e\u003c/Route\u003e是路由，component 指定路由對應的組件。 \u003cLink replace\u003e\u003c/Link\u003e 的 replace 屬性可以進行路由的取代替換，取代當前瀏覽器路由地址並跳轉。 動態路由：\u003cRoute path=\"/news/:id\" component={News}\u003e\u003c/Route\u003e。 function Home(params) { return ( \u003cdiv\u003e \u003ch1\u003eadmin首頁\u003c/h1\u003e \u003c/div\u003e ); } function Me(params) { console.log(params); return ( \u003cdiv\u003e \u003ch1\u003eadmin個人頁面\u003c/h1\u003e \u003c/div\u003e ); } function Product(params) { return ( \u003cdiv\u003e \u003ch1\u003eadmin產品頁面\u003c/h1\u003e \u003c/div\u003e ); } function News(params) { console.log(params) return ( \u003cdiv\u003e 新聞頁 新聞 id: {params.match.params.id} \u003c/div\u003e ) } class App extends React.Component { render() { // 這裡的 search 是 query string // 可以傳 state let meObj = { pathname: \"/me\", // 路徑 search: \"?username=admin\", // get 請求參數 hash: \"#abc\", // 設置 hash 錨值 state: { msg: \"helloWorld\" }, // 傳入組件的數據 }; return ( \u003cdiv id=\"app\"\u003e {/* 全局 */} \u003cdiv\u003e所有頁面都顯示的內容\u003c/div\u003e {/* Router 可以在一個組件中寫多個 */} {/* \u003cRouter\u003e \u003cRoute path=\"/\" exact component={() =\u003e (\u003cdiv\u003e首頁\u003c/div\u003e)}\u003e\u003c/Route\u003e \u003cRoute path=\"/me\" component={() =\u003e (\u003cdiv\u003eme\u003c/div\u003e)}\u003e\u003c/Route\u003e \u003cRoute path=\"/product\" component={() =\u003e (\u003cdiv\u003eproduct\u003c/div\u003e)}\u003e\u003c/Route\u003e \u003c/Router\u003e */} {/* Router 設置基礎路徑 basename */} \u003cRouter basename=\"/admin\"\u003e \u003cdiv className=\"nav\"\u003e \u003cLink to=\"/\"\u003e首頁\u003c/Link\u003e \u003cLink to=\"/product\"\u003e產品\u003c/Link\u003e {/* Link 可以設置 to 屬性進行頁面跳轉，to 屬性可以直接寫路徑的字符串，也可以通過 1 個對象，進行路進的配置 */} {/* replace 屬性 將新地址制換成歷史訪問紀錄的原地址 */} \u003cLink to={meObj} replace\u003e個人中心\u003c/Link\u003e {/* 動態路由 */} \u003cLink to=\"/news/456789\"\u003enews\u003c/Link\u003e \u003c/div\u003e \u003cRoute path=\"/\" exact component={Home}\u003e\u003c/Route\u003e \u003cRoute path=\"/product\" exact component={Product}\u003e\u003c/Route\u003e \u003cRoute path=\"/me\" exact component={Me}\u003e\u003c/Route\u003e {/* 動態路由 */} \u003cRoute path=\"/news/:id\" component={News}\u003e\u003c/Route\u003e \u003c/Router\u003e \u003c/div\u003e ); } } export default App; 重定向組件與 Switch 組件 重定向組件：如果訪問某個組件時，如果有重定向組件，那麼就會修改頁面路徑，使得頁面內容顯示為所定向路徑的內容。 Switch 組件：讓 Switch 組件內容的 Route 只匹配一個，只要匹配到了，剩餘的規則就不再匹配。 建議配置路由時要使用 Switch 組件，這樣路由的配置邏輯比較謹慎。 // 重定向組件 // 如果訪問某個組件時，如果有重定向組件，那麼就會修改頁面路徑，使得頁面內容顯示為所定向路徑的內容 // Switch 組件 // 讓 Switch 組件內容的 Route 只匹配一個，只要匹配到了，剩餘的規則就不再匹配 import { Redirect, Switch } from \"react-router-dom\"; function LoginInfo(params) { // params.loginSuccess = 'success' // params.loginSuccess = 'fail if (params.location.state.loginState === \"success\") { return ( // 重定向組件 \u003cRedirect to=\"/admin\"\u003e\u003c/Redirect\u003e ); } else { return \u003cRedirect to=\"/login\"\u003e\u003c/Redirect\u003e; } } let formCom = () =\u003e { let pathObj = { pathname: \"/loginInfo\", state: { loginState: \"success\", }, }; return ( \u003cdiv\u003e \u003ch1\u003e表單驗證\u003c/h1\u003e \u003cLink to={pathObj}\u003e登入後表單驗證\u003c/Link\u003e \u003c/div\u003e ); }; class ChildCom extends React.Component { constructor(props) { super(props); } render() { return ( \u003cdiv\u003e \u003cbutton onClick={this.clickEvent}\u003e跳轉到首頁\u003c/button\u003e \u003c/div\u003e ); } clickEvent = () =\u003e { console.log(this.props); // 可以傳值 // this.props.history.push(\"/\", {msg: \"這是由 ChildCom 發給首頁的數據\"}) // this.props.history.replace(\"/\", {msg: \"這是由 ChildCom 發給首頁的數據\"}) // 前進 this.props.history.go(1); this.props.history.goForward(); // 後退 this.props.history.go(-1); this.props.history.goBack(); }; } class App extends React.Component { render() { return ( \u003cdiv\u003e \u003cRouter\u003e \u003cSwitch\u003e \u003cRoute path=\"/\" exact component={(props) =\u003e { console.log(props); return \u003ch1\u003e首頁\u003c/h1\u003e; }} \u003e\u003c/Route\u003e \u003cRoute path=\"/form\" exact component={formCom}\u003e\u003c/Route\u003e \u003cRoute path=\"/login\" exact component={() =\u003e \u003ch1\u003e登入頁\u003c/h1\u003e} \u003e\u003c/Route\u003e \u003cRoute path=\"/loginInfo\" exact component={LoginInfo}\u003e\u003c/Route\u003e \u003cRoute path=\"/admin\" exact component={() =\u003e \u003ch1\u003eAdmin\u003c/h1\u003e}\u003e\u003c/Route\u003e {/* Router 會全部匹配，所以如果有兩個相同的 path 會兩個都匹配 */} {/* 所以需要用到 Switch 去匹配，匹配到一個成功就不會繼續匹配 */} \u003cRoute path=\"/abc\" exact component={() =\u003e \u003ch1\u003eabc1\u003c/h1\u003e}\u003e\u003c/Route\u003e \u003cRoute path=\"/","date":"2020-08-05","objectID":"/react_learn_note/:6:2","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"狀態管理 解決 React 數據管理（狀態管理），用於中大型項目，數據量龐大，組件之間數據交互較多的情況下使用。 如果你不知道是否需要使用 Redux ，那麼你就不需要用他。Redux 是個給 JavaScript 應用程式所使用的可預測 state 容器，Redux 跟 React 並沒有關係，你可以用 React、Angular、Ember、jQuery 或甚至原生 JavaScript 來撰寫 Redux 應用程式。 功能 解決組件的數據通信 解決數據和交互較多的應用 ","date":"2020-08-05","objectID":"/react_learn_note/:7:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"redux 安裝 npm install --save redux 工具 store: 數據倉庫，保存數據的地方 State: state 是一個對象，這個對象包含整個應用所需要的數據 Action: 一個動作，觸發數據改變的方法 Dispatch: 將動作觸發成方法 Reducer: 是一個函數，通過獲取動作，改變數據，生成一個新的狀態，從而改變頁面 使用 import { createStore } from \"redux\"; // 用於通過動作，創建新的 state // reduce 有兩個作用，一個釋初始化數據，第二個是通過獲取動作，改變數據 const reducer = function (state = { num: 0 }, action) { switch (action.type) { case \"add\": state.num++; break; case \"decrement\": state.num--; break; default: break; } return { ...state }; // 相當於對象的 COPY }; // 創建倉庫 const store = createStore(reducer); function add() { // 通過倉庫的方法 dispatch 進數據修改 // dispatch 觸發 reducer store.dispatch({ type: \"add\" }); console.log(store.getState()); } function decrement() { store.dispatch({ type: \"decrement\" }); console.log(store.getState()); } const Counter = function () { let state = store.getState(); return ( \u003cdiv\u003e \u003ch1\u003e計數數量：{state.num}\u003c/h1\u003e \u003cbutton onClick={add}\u003e+1\u003c/button\u003e \u003cbutton onClick={decrement}\u003e-1\u003c/button\u003e \u003c/div\u003e ); }; ReactDOM.render(\u003cCounter /\u003e, document.querySelector(\"#root\")); // 監聽數據變化，重新渲染 // 當數據改變時觸發 store.subscribe(() =\u003e { ReactDOM.render(\u003cCounter /\u003e, document.querySelector(\"#root\")); }); ","date":"2020-08-05","objectID":"/react_learn_note/:7:1","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"react-redux react-redux 是 redux 的擴展套件，用來綁定 redux。 安裝 npm install --save react-redux 工具 Provider：自動將 store 裡的 state 和組件進行關聯 connect：將數據倉庫的 state 和修改 state 的方法映射到組件上，形成新的組件 使用 import { createStore } from \"redux\"; import { Provider, connect } from 'react-redux' class Counter extends React.Component { render() { // 計數，通過 store 的 state 傳給 props，直接通過 props 就可以將 state 的數據獲取 const value = this.props.value; // 將修改數據的事件或者方法傳入到 props const onAddClick = this.props.onAddClick; // 等同於 VueX 的 mapMutation mapState return ( \u003cdiv\u003e \u003ch1\u003e計數數量：{value}\u003c/h1\u003e \u003cbutton onClick={onAddClick}\u003e+1\u003c/button\u003e \u003c/div\u003e ) } } // 動作 const addAction = { type: 'add' } const reducer = function (state = { num: 0 }, action) { switch (action.type) { case \"add\": state.num++; break; case \"decrement\": state.num--; break; default: break; } return { ...state }; // 相當於對象的 COPY }; const store = createStore(reducer); // 將 state 映射到 props 函數 function mapStateToProps(state) { return { value: state.num } } // 將修改 state 數據的方法，映射到 props，默認會傳入 store 裡的 dispatch 方法 function mapDispatchToProps(dispatch) { return { onAddClick: () =\u003e { dispatch(addAction) } } } // 將上面的這兩個方法，將數據倉庫的 state 和修改 state 的方法映射到組件上，形成新的組件 const NewApp = connect( mapStateToProps, mapDispatchToProps )(Counter) // Provider 組件：自動將 store 裡的 state 和組件進行關聯 ReactDOM.render( \u003cProvider store={store}\u003e \u003cNewApp\u003e\u003c/NewApp\u003e \u003c/Provider\u003e, document.querySelector(\"#root\") ) ","date":"2020-08-05","objectID":"/react_learn_note/:7:2","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["前端"],"content":"Reference 2020最新前端_React实战教学【老陈打码】- BiliBili React Create React App - Github Redux ","date":"2020-08-05","objectID":"/react_learn_note/:8:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter"],"title":"React 學習筆記","uri":"/react_learn_note/"},{"categories":["Python"],"content":"前言 關於 Flask 跨域接收請求的設置真的蠻好配置的，我想並不難，但我還是稍微寫一下，避免新手不知道怎麼做。 ","date":"2020-08-05","objectID":"/flask_cors/:1:0","tags":["Python","Flask","CORS","跨域"],"title":"Flask 跨域設置","uri":"/flask_cors/"},{"categories":["Python"],"content":"安裝 跨域有 flask_cors 這個工具。 pip install flask_cors ","date":"2020-08-05","objectID":"/flask_cors/:2:0","tags":["Python","Flask","CORS","跨域"],"title":"Flask 跨域設置","uri":"/flask_cors/"},{"categories":["Python"],"content":"配置 from flask import Flask, jsonify, request from flask_cors import CORS app = Flask(__name__) # enable CORS CORS(app) if __name__ == \"__main__\": app.run(debug=True) ","date":"2020-08-05","objectID":"/flask_cors/:3:0","tags":["Python","Flask","CORS","跨域"],"title":"Flask 跨域設置","uri":"/flask_cors/"},{"categories":["Python"],"content":"前言 因為我寫的上一篇文章是”Flask 中使用 MySQL\"，文章內容有提及 JWT 的使用，這篇就是寫一下我在 JWT 上的使用。 ","date":"2020-08-05","objectID":"/flask_jwt/:1:0","tags":["Python","Flask","JWT","Token"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"Cookie Session Cookie 和 LocalStorage 最大的區別是 Cookie 可以設置時效性，而LocalStorage 不行。 在 JWT 授權認證技術還沒出來之前，我們是使用 Cookie 和 Session 來做驗證，分別是前端（Front End）和後端（Back End）的本地存儲。過程如下： ","date":"2020-08-05","objectID":"/flask_jwt/:2:0","tags":["Python","Flask","JWT","Token"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"JWT ","date":"2020-08-05","objectID":"/flask_jwt/:3:0","tags":["Python","Flask","JWT","Token"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"理論部份 因為 Cookie Session 這種方式太過繁瑣，所以出來了 JWT 這樣的技術，原名 (JSON Web Tokens)，就是帶時效的 Token。主要差別是，Server 端不需要存 Session，大致情形如下： JWT 主要分為三段，個別為 header、payload 與 signature，中間以 . 做區隔，每一段都是透過 Base64Url 去編碼，中間的 payload 有時候會加密。 e.g. eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJlbWFpbCI6Imhpcm9AZ21haWwuY29tIn0. WAKjPd_0qcEG3dA9pEwAiw-0ADb8VwqFlSWiIYJTymo header 存放 token 型別與加密方式 。 { \"alg\": \"HS256\", // 加密方式 \"typ\": \"JWT\" // token 型別 } payload 存放需要傳遞的訊息。因為只透過編碼轉換「未經過加密」，不建議在裡面放重要資訊。 另外官方有提供一些可以用的屬性大概分為： iss: 發行人 exp: 到期日 sub: 主題 aud: 收件人 nbf: 不接受早於…日期/時間 iat: 發行時間 jti: 唯一識別符，JWT 只能使用一次 signature 最後的部分，有點像是我們平常買東西條碼上最後的檢查碼，首先會先取得 header 裡的加密方式 SHA256，再透過以下方式產生： HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret ) secret 則是可以打上自己要打的，最後一樣會轉換成 Base64Url： 再把三段加在一起就算是 JWT 了！ ","date":"2020-08-05","objectID":"/flask_jwt/:3:1","tags":["Python","Flask","JWT","Token"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"使用時機 JWT 的主要目的只是「 確立資料來源以及可信度 」。因此在應用上也會限制較多。以下是較常被使用的時機： 跨伺服器下的請求 可以參考運作原理的圖，如果我們同時擁有許多伺服器，可以把身份驗證伺服器獨立出來，登入後使用 JWT 就可以在不同伺服器遊走。 一次性、時效短的請求 因為 JWT 不能主動撤銷，一般用於會員身份驗證會不太適合，多用於一次性下載檔案，或是時間限制內更改密碼等等… APP 身份驗證 一般 APP 是不存在 Session 的，所以在持續身份驗證上可以使用 JWT，但要確保使用者的執行環境是安全的 ","date":"2020-08-05","objectID":"/flask_jwt/:3:2","tags":["Python","Flask","JWT","Token"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"實作部份 安裝 pip install flask-jwt-extended 引入與基本使用 為了快速了解怎麼用，例子中只會顯示重要核心代碼。 注意點： @jwt_required 裝飾器是用來判斷請求 Header 是否帶有 Token。 下面例子的 /login 使用 create_access_token() 生成 Token。 /protected 是獲取放在 請求 Header 的 Token 判是否正確，相對的，可以看 /user/update/phone。 前端請求需要在 Header 添加 Authorization: Bearer \u003caccess_token\u003e，關於 Axios 怎麼在請求 Header 添加 Token 我之前有在 Vue 技巧與經驗 這篇文章的請求部份寫到。 生成 Token 的依據（identity）不能是密碼，可以是 UserName 或是 UserID。 一般 Token 的時效是 15 分鐘左右，如果想要延長可以設置。 get_jwt_identity() 獲取之前 Token 生成依據的內容。 from flask import Flask, jsonify, request # 引入 JWT from flask_jwt_extended import ( JWTManager, jwt_required, create_access_token, get_jwt_identity ) app = Flask(__name__) # Setup the Flask-JWT-Extended extension app.config['JWT_SECRET_KEY'] = 'super-secret' # Change this! jwt = JWTManager(app) # ... # Provide a method to create access tokens. The create_access_token() # function is used to actually generate the token, and you can return # it to the caller however you choose. # 用戶登入 @app.route('/user/login', methods=['GET', 'POST']) def user_login(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 requestEmail = request.form.get('email') requestPassword = request.form.get('password') sqlSearchResult = [] # 查詢資料庫 cursor.execute( \"SELECT id, username, email, password FROM user WHERE email = %s;\", (requestEmail,)) for (id, username, email, password) in cursor: sqlSearchResult.append({ \"id\": id, \"username\": username, \"email\": email, \"password\": password }) # md5 加密轉換 transferPassword = hashlib.md5(requestPassword.encode()) print(transferPassword.hexdigest()) print(sqlSearchResult) # 如果沒有資料 if cursor.rowcount \u003c 1: response_object['message'] = 'This Account not exist.' response_object['data'] = False # 如果有資料 else: # 如果密碼正確 if str(transferPassword.hexdigest()) == str(sqlSearchResult[0]['password']): print('password: ' + password + ', resultPWD: ' + sqlSearchResult[0]['password']) response_object['message'] = 'Sign in success.' response_object['data'] = True response_object['user_id'] = sqlSearchResult[0]['id'] # Identity can be any data that is json serializable # 產生 jwt_token, 並將 token 的 expires 取消 response_object['jwt_token'] = create_access_token( identity=sqlSearchResult[0]['id'], expires_delta=False) else: response_object['message'] = 'Password is not true.' response_object['data'] = False return jsonify(response_object) # Protect a view with jwt_required, which requires a valid access token # in the request to access. @app.route('/protected', methods=['GET']) @jwt_required def protected(): # Access the identity of the current user with get_jwt_identity current_user = get_jwt_identity() return jsonify(logged_in_as=current_user), 200 # 修改更新用戶 phone 資料 # 這裡前端要先判斷輸入的新 Phone 是否跟原本的一樣，如果相同就不准請求 @app.route(\"/user/update/phone\", methods=['GET', 'POST']) @jwt_required def user_update_phone(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 # 請求資料 requestId = request.form.get('id') requestPhone = request.form.get('phone') # 驗證 jwt_token current_user = get_jwt_identity() # 驗證失敗 回傳失敗 if not current_user: response_object['message'] = 'anonymous user' response_object['data'] = False return jsonify(response_object) # 用 id 查詢用戶的 phone cursor.execute( \"SELECT id, phone FROM user WHERE id = %s;\", (requestId,)) # 有找到資料 if cursor.rowcount \u003e 0: # 更新資料 sql = \"UPDATE user SET phone = %sWHERE id = %s;\" cursor.execute(sql, (requestPhone, requestId)) # 確認資料有存入資料庫 connection.commit() response_object['message'] = 'Update phone success.' response_object['data'] = True # 沒有找到資料 else: response_object['message'] = 'Update phone fail.' response_object['data'] = False return jsonify(response_object) if __name__ == '__main__': app.run() ","date":"2020-08-05","objectID":"/flask_jwt/:3:3","tags":["Python","Flask","JWT","Token"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"部份保護 route @jwt_required 裝飾器是該 route 接收到的請求 Header 必須要有 JWT Token，jwt_optional() 裝飾器，可以使需要保護的數據與不被保護的數據同時在 route 中使用（官方說法），但跟 @jwt_required 裝飾器一樣是 Token 如果失效會回傳失效訊息。 from flask import Flask, jsonify, request from flask_jwt_extended import ( JWTManager, jwt_optional, create_access_token, get_jwt_identity ) app = Flask(__name__) # Setup the Flask-JWT-Extended extension app.config['JWT_SECRET_KEY'] = 'super-secret' # Change this! jwt = JWTManager(app) @app.route('/login', methods=['POST']) def login(): username = request.json.get('username', None) password = request.json.get('password', None) if not username: return jsonify({\"msg\": \"Missing username parameter\"}), 400 if not password: return jsonify({\"msg\": \"Missing password parameter\"}), 400 if username != 'test' or password != 'test': return jsonify({\"msg\": \"Bad username or password\"}), 401 access_token = create_access_token(identity=username) return jsonify(access_token=access_token), 200 @app.route('/partially-protected', methods=['GET']) @jwt_optional def partially_protected(): # If no JWT is sent in with the request, get_jwt_identity() # will return None current_user = get_jwt_identity() if current_user: return jsonify(logged_in_as=current_user), 200 else: return jsonify(logged_in_as='anonymous user'), 200 if __name__ == '__main__': app.run() ","date":"2020-08-05","objectID":"/flask_jwt/:3:4","tags":["Python","Flask","JWT","Token"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"黑名單（Black List） 應用場景是當我們之前的 Token 錯誤或失效（如果有設置自動登入，一般 Token 會設置 7 天有效），或是登出、重新登入、登入等，都需要將舊的 Token 加入黑名單。 from flask import Flask, request, jsonify from flask_jwt_extended import ( JWTManager, jwt_required, get_jwt_identity, create_access_token, create_refresh_token, jwt_refresh_token_required, get_raw_jwt ) # Setup flask app = Flask(__name__) # Enable blacklisting and specify what kind of tokens to check # against the blacklist app.config['JWT_SECRET_KEY'] = 'super-secret' # Change this! app.config['JWT_BLACKLIST_ENABLED'] = True app.config['JWT_BLACKLIST_TOKEN_CHECKS'] = ['access', 'refresh'] jwt = JWTManager(app) # A storage engine to save revoked tokens. In production if # speed is the primary concern, redis is a good bet. If data # persistence is more important for you, postgres is another # great option. In this example, we will be using an in memory # store, just to show you how this might work. For more # complete examples, check out these: # https://github.com/vimalloc/flask-jwt-extended/blob/master/examples/redis_blacklist.py # https://github.com/vimalloc/flask-jwt-extended/tree/master/examples/database_blacklist blacklist = set() # For this example, we are just checking if the tokens jti # (unique identifier) is in the blacklist set. This could # be made more complex, for example storing all tokens # into the blacklist with a revoked status when created, # and returning the revoked status in this call. This # would allow you to have a list of all created tokens, # and to consider tokens that aren't in the blacklist # (aka tokens you didn't create) as revoked. These are # just two options, and this can be tailored to whatever # your application needs. @jwt.token_in_blacklist_loader def check_if_token_in_blacklist(decrypted_token): jti = decrypted_token['jti'] return jti in blacklist # Standard login endpoint @app.route('/login', methods=['POST']) def login(): username = request.json.get('username', None) password = request.json.get('password', None) if username != 'test' or password != 'test': return jsonify({\"msg\": \"Bad username or password\"}), 401 ret = { 'access_token': create_access_token(identity=username), 'refresh_token': create_refresh_token(identity=username) } return jsonify(ret), 200 # Standard refresh endpoint. A blacklisted refresh token # will not be able to access this endpoint @app.route('/refresh', methods=['POST']) @jwt_refresh_token_required def refresh(): current_user = get_jwt_identity() ret = { 'access_token': create_access_token(identity=current_user) } return jsonify(ret), 200 # Endpoint for revoking the current users access token @app.route('/logout', methods=['DELETE']) @jwt_required def logout(): jti = get_raw_jwt()['jti'] blacklist.add(jti) return jsonify({\"msg\": \"Successfully logged out\"}), 200 # Endpoint for revoking the current users refresh token @app.route('/logout2', methods=['DELETE']) @jwt_refresh_token_required def logout2(): jti = get_raw_jwt()['jti'] blacklist.add(jti) return jsonify({\"msg\": \"Successfully logged out\"}), 200 # This will now prevent users with blacklisted tokens from # accessing this endpoint @app.route('/protected', methods=['GET']) @jwt_required def protected(): return jsonify({'hello': 'world'}) if __name__ == '__main__': app.run() ","date":"2020-08-05","objectID":"/flask_jwt/:3:5","tags":["Python","Flask","JWT","Token"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"Reference Flask-JWT-Extended’s Documentation 淺談 Session 與 JWT 差異 ","date":"2020-08-05","objectID":"/flask_jwt/:4:0","tags":["Python","Flask","JWT","Token"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"前言 我一開始學 Flask 時是看 Flask 的官方教學學的，不得不說Flask 官方文檔寫得很好。因為 Flask 官方教學是使用 Sqlite 做為數據庫，但是我想要使用 MySQL，在自己網上搜索，加上自己的鑽研手做，這裡紀錄我摸索的結果。因為我偏好使用原生 SQL 語法，所以下面的數據庫操作都是原生語句，例子也是我之前做的某個項目裡面拿出來的。 ","date":"2020-08-04","objectID":"/flask_mysql/:1:0","tags":["Python","Flask","MySQL","Database","數據庫"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"安裝 pip install mysql-connector-python ","date":"2020-08-04","objectID":"/flask_mysql/:2:0","tags":["Python","Flask","MySQL","Database","數據庫"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"引入、連接數據庫 因為是 MySQL，所以自己要在自己的電腦本地數據庫寫好要用的數據庫。下面的連接參數要自己改。 import mysql.connector from mysql.connector import Error # 連接 MySQL 資料庫 connection = mysql.connector.connect( host='localhost', # 主機名稱 database='myTelegram', # 資料庫名稱 user='Rem', # 帳號 password='') # 密碼 cursor = connection.cursor(buffered=True) cursor.execute(\"SELECT DATABASE();\") record = cursor.fetchone() ","date":"2020-08-04","objectID":"/flask_mysql/:3:0","tags":["Python","Flask","MySQL","Database","數據庫"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"CRUD CRUD 就是 Create（新增）、Read（讀取）、Update（更新）、Delete（刪除），數據庫基本操作。 ","date":"2020-08-04","objectID":"/flask_mysql/:4:0","tags":["Python","Flask","MySQL","Database","數據庫"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"Create 新增 以註冊帳戶並驗證完 Email Captcha 後，將帳戶資料增入 Database 為例子。這裡的設計概念是註冊後不會將帳戶資料寫入數據庫，註冊完會將暫時的帳戶資料存到數據庫，註冊的下一步是驗證 Email，驗證完發送到 Email 的 Captcha 就可以存入數據庫。關於發送 Email，我會另外寫一篇文章。 註：因為 Flask 可以寫 Restful，所以會出現判斷請求方法是不是 POST 或是 GET，增加複用性。 from flask import Flask, jsonify, request from flask_cors import CORS import mysql.connector from mysql.connector import Error # 引入 string import string app = Flask(__name__) # enable CORS CORS(app) # 註冊 email 驗證後的緩存 registerTempData = { \"id\": \"\", \"username\": \"\", \"email\": \"\", \"phone\": \"\", \"password\": \"\", } # 全局驗證碼 captcha = 0 # 驗證 註冊的 Email @app.route(\"/user/validateEmail\", methods=['GET', 'POST']) def user_register_email_validate(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 requestCaptcha = request.form.get('captcha') print(\"requestCaptcha: \" + str(requestCaptcha)) print(\"captcha: \" + str(captcha)) # 如果驗證碼相同 if str(requestCaptcha) == str(captcha): global registerTempData # 新增資料 sql = \"INSERT INTO user (id, username, email, phone, password) VALUES (%s, %s, %s, %s, %s);\" # 將緩存的註冊資料加入 new_data = (registerTempData[\"id\"], registerTempData[\"username\"], registerTempData[\"email\"], registerTempData[\"phone\"], registerTempData[\"password\"]) print(new_data) cursor = connection.cursor() cursor.execute(sql, new_data) # 確認資料有存入資料庫 connection.commit() response_object['message'] = 'Your account is activated!' response_object['data'] = True # 初始化 registerTempData = { \"id\": \"\", \"username\": \"\", \"email\": \"\", \"phone\": \"\", \"password\": \"\", } else: response_object['message'] = 'The captcha is not true!' response_object['data'] = False return jsonify(response_object) 上面的 Code 需要注意的地方是全局變量如果要在局部函數中使用，就需要使用 global 聲明全局變量，像上面例子的 global registerTempData ","date":"2020-08-04","objectID":"/flask_mysql/:4:1","tags":["Python","Flask","MySQL","Database","數據庫"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"Read 讀取 ","date":"2020-08-04","objectID":"/flask_mysql/:5:0","tags":["Python","Flask","MySQL","Database","數據庫"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"普通查詢 就是 “查\"，這裡以返回某帳戶資訊為例： 下面的 @jwt_optional 是關於 JWT 的使用，因為不在這文章的討論範疇，所以不會細講。 # 返回用戶資訊 @app.route(\"/user/getDetail\", methods=['GET', 'POST']) @jwt_optional def user_getDetail(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 requestId = request.form.get('id') sqlSearchResult = [] # 驗證 jwt_token current_user = get_jwt_identity() # 驗證失敗 回傳失敗 if not current_user: response_object['message'] = 'anonymous user' response_object['data'] = False return jsonify(response_object) # 用 id 查詢用戶資訊 cursor.execute( \"SELECT id, username, email, phone, password FROM user WHERE id = %s;\", (requestId,)) for (id, username, email, phone, password) in cursor: sqlSearchResult.append({ \"id\": id, \"username\": username, \"email\": email, \"phone\": phone, \"password\": password }) print(sqlSearchResult) # 如果有資料 if cursor.rowcount \u003e 0: response_object['message'] = 'Searching is Success. Have Data' response_object['data'] = True # 將搜到的數據添入 response_object response_object.update({ 'userData': { 'id': sqlSearchResult[0]['id'], 'username': sqlSearchResult[0]['username'], 'email': sqlSearchResult[0]['email'], 'phone': sqlSearchResult[0]['phone'], 'password': sqlSearchResult[0]['password'] } }) # 如果沒有資料 else: response_object['message'] = 'There is not this account in the database.' response_object['data'] = False return jsonify(response_object) ","date":"2020-08-04","objectID":"/flask_mysql/:5:1","tags":["Python","Flask","MySQL","Database","數據庫"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"模糊搜索 糊糊搜索最關鍵的地方就是如何將 Keyword 加入 SQL 語句，下面是個實際例子： # 模糊搜索 所有 channelType 是 group 的群 @app.route(\"/user/channels/searchChannels\", methods=['GET', 'POST']) @jwt_optional def user_channels_search_channels(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 requestKeyword = request.form.get('keyword') sqlSearchResult = [] # 驗證 jwt_token current_user = get_jwt_identity() # 驗證失敗 回傳失敗 if not current_user: response_object['message'] = 'anonymous user' response_object['data'] = False return jsonify(response_object) # 用 keyword 模糊查詢 所有 channel (channelType = group) cursor.execute( \"SELECT id, channelType, adminId, channelName FROM channel WHERE channelType = 'group' \\ AND (id LIKE CONCAT('%', %s, '%') OR adminId LIKE CONCAT('%', %s, '%') OR \\ channelName LIKE CONCAT('%', %s, '%')) GROUP BY id;\", (requestKeyword, requestKeyword, requestKeyword)) for (id, channelType, adminId, channelName) in cursor: sqlSearchResult.append({ \"id\": id, \"channelType\": channelType, \"adminId\": adminId, \"channelName\": channelName, }) # 如果有 資料 if cursor.rowcount \u003e 0: response_object['message'] = 'Get the channel List success.' response_object['data'] = True # 將資料添加到 response_object response_object.update({ 'searchResult': sqlSearchResult }) # 沒有 message else: response_object['message'] = 'There is no data.' response_object['data'] = False return jsonify(response_object) ","date":"2020-08-04","objectID":"/flask_mysql/:5:2","tags":["Python","Flask","MySQL","Database","數據庫"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"Update 更新 以些改某個帳戶資料為例 # 修改更新用戶 phone 資料 # 這裡前端要先判斷輸入的新 Phone 是否跟原本的一樣，如果相同就不准請求 @app.route(\"/user/update/phone\", methods=['GET', 'POST']) @jwt_optional def user_update_phone(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 # 請求資料 requestId = request.form.get('id') requestPhone = request.form.get('phone') # 驗證 jwt_token current_user = get_jwt_identity() # 驗證失敗 回傳失敗 if not current_user: response_object['message'] = 'anonymous user' response_object['data'] = False return jsonify(response_object) # 用 id 查詢用戶的 phone cursor.execute( \"SELECT id, phone FROM user WHERE id = %s;\", (requestId,)) # 有找到資料 if cursor.rowcount \u003e 0: # 更新資料 sql = \"UPDATE user SET phone = %sWHERE id = %s;\" cursor.execute(sql, (requestPhone, requestId)) # 確認資料有存入資料庫 connection.commit() response_object['message'] = 'Update phone success.' response_object['data'] = True # 沒有找到資料 else: response_object['message'] = 'Update phone fail.' response_object['data'] = False return jsonify(response_object) ","date":"2020-08-04","objectID":"/flask_mysql/:6:0","tags":["Python","Flask","MySQL","Database","數據庫"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"Delete 刪除 以刪除某帳戶為例： # 刪除帳戶 @app.route(\"/user/delete\", methods=['GET', 'POST']) @jwt_optional def user_delete_account(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 # 請求資料 requestId = request.form.get('id') requestPassword = request.form.get('password') sqlSearchResult = [] # 驗證 jwt_token current_user = get_jwt_identity() # 驗證失敗 回傳失敗 if not current_user: response_object['message'] = 'anonymous user' response_object['data'] = False return jsonify(response_object) # 用請求 id 查詢該 id 是否存在 cursor.execute( \"SELECT id, username FROM user WHERE id = %s;\", (requestId,)) # 如果沒找到該 id if cursor.rowcount \u003c 1: response_object['message'] = 'This account is not exist.' response_object['data'] = False return jsonify(response_object) # 先判斷 requestPassword 是否跟原來的密碼相符 cursor.execute( \"SELECT id, password FROM user WHERE id = %s;\", (requestId,)) for (id, password) in cursor: sqlSearchResult.append({ \"id\": id, \"password\": password }) # md5 加密轉換 transferPassword = hashlib.md5(requestPassword.encode()) # 如果密碼相等 if transferPassword.hexdigest() == sqlSearchResult[0]['password']: # 更新資料 # 刪除用戶的基本資料 sql = \"DELETE FROM user WHERE id = %s;\" cursor.execute(sql, (requestId,)) # 確認資料有存入資料庫 connection.commit() # 刪除用戶的好友資料 # 用 id 查詢用戶的朋友 id 統計好友數 cursor.execute( \"SELECT id, friendId FROM friend WHERE id = %s;\", (requestId,)) # 有好友 if cursor.rowcount \u003e 0: # 循環刪除 for i in range(0, cursor.rowcount * 2): sql = \"DELETE FROM friend WHERE id = %sor friendId = %s;\" cursor.execute(sql, (requestId, requestId)) # 確認資料有存入資料庫 connection.commit() # token 加入黑名單 jti = get_raw_jwt()['jti'] blacklist.add(jti) response_object['message'] = 'Delete the account success.' response_object['data'] = True else: response_object['message'] = 'Delete the account fail. The password is not true.' response_object['data'] = False return jsonify(response_object) ","date":"2020-08-04","objectID":"/flask_mysql/:7:0","tags":["Python","Flask","MySQL","Database","數據庫"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"Reference Python 使用 MySQL Connector 操作 MySQL/MariaDB 資料庫教學與範例 ","date":"2020-08-04","objectID":"/flask_mysql/:8:0","tags":["Python","Flask","MySQL","Database","數據庫"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Moment"],"content":"學習態度 讀萬卷書不如行萬里路。 我認為學習工程相關最重要的莫過於要親身去實踐手作，而非靠一堆理論知識和小實驗去學習，做項目讓自己有經驗莫過於看一堆理論知識以及為考試或光鮮亮麗的文憑。切記，實作是刻印在人的身體。 再者，學習是靠興趣的，想要學好軟件工程，需要愛上編程，如果只是像學校老師或學長姊得學習步調走，而不自己主動去學習並實作自己感興趣部份，你將永遠不會學會編程。 ","date":"2020-08-04","objectID":"/how_to_learn_cs/:1:0","tags":["CS","計算機科學","軟件工程","工程學"],"title":"關於學習軟件工程與技術的方法","uri":"/how_to_learn_cs/"},{"categories":["Moment"],"content":"學習步調 學習一門技術分幾個階段： 初步認識，了解原理等理論知識。 會寫 Hello world，學會基礎使用語法。 熟練該門語言，並能自己使用這技術開發中小型 Demo 與項目。 精通該語言，能駕馭該門技術，開發大型項目。 不要學到了 Hello world 就認為自己已經精通了，你還隻是菜鳥。不要還沒學會爬就想跑步，除非你自認天才。 ","date":"2020-08-04","objectID":"/how_to_learn_cs/:2:0","tags":["CS","計算機科學","軟件工程","工程學"],"title":"關於學習軟件工程與技術的方法","uri":"/how_to_learn_cs/"},{"categories":["Moment"],"content":"關於文檔 我自己認為文檔在開發項目的比重並沒有很重要，要求文檔的前提是整體隊伍有一定的水平實力能去實現，不然寫出來的文檔也無法實現。做項目的是人不是文字，文檔頂多起到開發輔助的效用。然而，現在學校很多比賽卻是重視文檔，各種 PPT 大賽到 PS、PR 編程，這事實讓人痛心，使很多有實力的人因為文檔的繁文縟節而退卻。要真正做到的是項目不是靠文字或嘴巴或白嫖網上開源代碼……等方法實現，而是靠自己紮實編寫的代碼。 ","date":"2020-08-04","objectID":"/how_to_learn_cs/:3:0","tags":["CS","計算機科學","軟件工程","工程學"],"title":"關於學習軟件工程與技術的方法","uri":"/how_to_learn_cs/"},{"categories":["Moment"],"content":"代碼技巧與學習管道 我認為有幾個技能是一個程序員必備的： 學會使用搜索引擎關鍵字。 翻牆使用 Google、Github、Stackoverflow、Youtube…等學習網頁。 官方文檔有時是最好的選擇。 編程注意註解，還有變量函數命名、代碼編排，儘可能讓代碼精簡。 要捨得花時間學習新知識。 Git、Github、Markdown 的使用，寫正式報告建議使用 LaTeX。文檔交 PDF 格式。 自己的 Blog，用來創造發表自己的想法與技巧。 保持上進心、好奇心與謙虛，要勇於探索新事物，且人上有人，天外有天。 最後希望大家能擇你所愛，愛你所擇，如果敲代碼是你的興趣，那恭喜你，你有自己的愛好。 ","date":"2020-08-04","objectID":"/how_to_learn_cs/:4:0","tags":["CS","計算機科學","軟件工程","工程學"],"title":"關於學習軟件工程與技術的方法","uri":"/how_to_learn_cs/"},{"categories":["Moment"],"content":"來大陸前 今天是 2020/08/04，是我在中南大學本科生大二升大三的暑假，想想時光過得真快，已經兩年了，不知不覺大一時自己還只是一隻菜鳥，現在還是菜鳥，來大陸唸中南大學前，我其實對於大陸不熟悉，畢竟一直在台灣讀的書，甚至一直猶豫，不敢踏出舒適圈，爸媽軟硬兼施強迫我要去大陸唸書，當時我有鄭州大學和中南大學的錄取通知，我自己思考後決定了中南大學，畢竟是雙一流，福州大學因為當時已經決定錄取中南大學，所以我沒有去面試，這是我來中南的由來。至於選擇軟件工程，其實一開始我想要讀的是資訊工程，但是奈何大陸沒有科系（專業）是叫做資訊工程的，結果選錯選成軟件工程，原來大陸的資訊工程是計算機科學，但是現在也沒什麼好後悔的。 ","date":"2020-08-04","objectID":"/csu_freshman_sophomore/:1:0","tags":["CSU","中南大學","大陸","大一","大二"],"title":"我在中南大學軟件工程本科大一和大二的這兩年","uri":"/csu_freshman_sophomore/"},{"categories":["Moment"],"content":"大一 中南大學南校區01.png \" 中南大學南校區 大一大概是我最難適應的，高等數學、離散數學、線性代數真的很難，尤其是大陸的教科書教材我覺得不像台灣寫得那麼通俗易懂，給的例子有時也讓人費解，我還記得我掛科了，但是後面又渾渾噩噩地補考過了，自己的成績實在是差強人意，只有專業課寫 Code 我不容易掛科，我記得大一我的 C++ 是裸考沒複習，過是過了，但是沒去看歷屆，所以分數不如周遭的人高分，有時我仔細想想我大學生活到現在到底學了什麼，這時就真的很難受，答案是沒有，我不知道自己在學什麼，有什麼技術是自己可以有自信的？沒有…我覺得這一切都太荒謬了，上課耽誤了學習，我覺得大陸計算機教育最大的敗筆是只會搞虛的理論知識，忘記了既然讀的是工程學，就應該側重實作，從實作中學習理論，我無法理解為什麼上 C++ 不全程在電腦教室（機房）上課，為什麼考試要手寫代碼在紙上，不過聽說現在大一新生有改成在機房考試。再來，學校教的東西都很淺，如果你只是妥妥跟著學校安排學，你只會成為一名碼農，對計算機專業沒有興趣，只是看在錢多才讀這專業，說實在的，這是虛度人生，選擇了根本不是自己熱衷的專業。我大一根本就是在虛度光陰。 我和我朋友們在大一下報名了大學生創新創業立項，要說報名的一開始的感覺是什麼，那就是抱有理想，最後我已經從希望變絕望，原來所謂的學校比賽比的是文檔呀！我當時是當隊長，然而我卻對隊長這職務感到煩厭了，畢竟最後大家都因為課業沒時間參加比賽，然後也察覺其實這些比賽進到國家級的大多都是祖傳的項目，沒幾個人是有做實事的，虛假的表面，包裝起來的文檔。 大一最讓我感到新鮮的是長沙冬天下的雪景，但是大二就沒有了，看來雪景不是年年都有。 ","date":"2020-08-04","objectID":"/csu_freshman_sophomore/:2:0","tags":["CSU","中南大學","大陸","大一","大二"],"title":"我在中南大學軟件工程本科大一和大二的這兩年","uri":"/csu_freshman_sophomore/"},{"categories":["Moment"],"content":"大二 中南大學南校區02.jpg \" 中南大學南校區 大二上軟件工程學院的軟件工程併入計算機學院。 我們軟件工程 18 級從南校區搬到了鐵道校區，然而自習的地方真的很不舒服，很想進實驗室自習，鐵道的圖書館找不到自習的位置又小的可憐，然後不管是南校新校區還是鐵道的圖書館，最另讓我感到詬病的是佔座文化，佔著茅坑不拉屎，桌上有書或是水壺，但是座位上卻一直不見人影。鐵道校區真的蠻糟糕的，但其實我在南校區時就覺得宿舍環境糟糕了，沒想到鐵道更糟。然後也養成不喜歡去學校食堂吃東西，因為排隊排太長了，菜色大多也是辣的，不知不覺中，自己吃習慣了辣和重口味，回台灣吃飯時，竟然覺得台灣的菜沒味道。 我開始發現，所以我學的技術都是靠自學，學校教不了我任何東西，重新認識到自學的重要性，我缺乏做 Project 的經驗，所以我開始不重視學校的課程，但是該考試要背的還是會去背，好消息是我已經爭取到進老師的實驗室。 大二的寒假這時我也成年滿 20 歲了，但是 2020/1/11 沒有回台灣投票，但選總統的大事我還是有關注。因為疫情關係，大二下學期我在台灣和大家線上上課，大家都是遠程教學，我想我大二下越來越厭惡什麼文學編程，還有只會說不會做，出一張嘴的事物。話說大二下的編譯原理真的很難，幸好最後老師手下留情，沒有將考卷出的太難。 ","date":"2020-08-04","objectID":"/csu_freshman_sophomore/:3:0","tags":["CSU","中南大學","大陸","大一","大二"],"title":"我在中南大學軟件工程本科大一和大二的這兩年","uri":"/csu_freshman_sophomore/"},{"categories":["Moment"],"content":"對湖南長沙的感受 真的是鄉下耶，我以為長沙會發達一些，雖然我讀的是 985，但是實在不想不嘴一下，貴為 985 卻沒感到學校資源有多豐富。剛來大陸就因為不熟被別人騙，我覺得很過份，人情味和普遍素質不如台灣。然後也不喜歡在大陸辦事人員喜歡踢皮球的習慣，還有玩文字遊戲，拐彎抹角，辦事效率低，一堆形式主義，最痛恨的就是形式主義。但也不是沒有優點，像是其實很多同學普遍素質不錯，在一些意見上雖然不同，但也只是偶爾互相討論也互相包容理解，不曾發生嚴重口角。 ","date":"2020-08-04","objectID":"/csu_freshman_sophomore/:4:0","tags":["CSU","中南大學","大陸","大一","大二"],"title":"我在中南大學軟件工程本科大一和大二的這兩年","uri":"/csu_freshman_sophomore/"},{"categories":["Moment"],"content":"最後 現在正在寫這篇文章的我會對在大陸未來的出路感到迷茫，我也不會包裝自己，口才比不過別人，正在朝著變強努力中。或許最後會回台灣吧。 ","date":"2020-08-04","objectID":"/csu_freshman_sophomore/:5:0","tags":["CSU","中南大學","大陸","大一","大二"],"title":"我在中南大學軟件工程本科大一和大二的這兩年","uri":"/csu_freshman_sophomore/"},{"categories":["前端"],"content":"前言 經過許久寫 VueJS 的經驗，實在是有些技巧我想要紀錄下來，畢竟當時我摸索了很久，從一開始的不擅長到後面的熟練，經歷的 Project 很多。希望能幫助新手快速掌握 VueJS。 這文章不會教你 Vue 基礎語法等詳細的基礎部份。所以在看這篇文章時需要一些 Vue 基礎。 如果因為沒有範例觀摩的話，可以看我在 2020/06/30 - 2020/07/17 暑假實訓寫的個人空間系統 - Blog 前端。 ","date":"2020-07-31","objectID":"/vue_skill/:1:0","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"Vue-cli 腳手架使用 ","date":"2020-07-31","objectID":"/vue_skill/:2:0","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"創建應用 用了 CDN 引入就不能用 Vue-cli 了，整個的結構差太多，通常 CDN 引入就是 Demo 或是很小的專案某部分用來代替 JQuery 用。 大部分開發還是使用 Vue-cli 比較方便。關於使用 Vue-cli 現在使用 npm 可以自己選擇要裝哪些東西，使用越來越方便，通常我是建議自定義，因為 eslint 的標準太高了，每次打開瀏覽器 Console 就一堆警告。所以在後面的選擇將 Linter / Formatter 這一項按空白鍵（Space）去掉。目前我開發項目初始構建只需要下列三個就暫時夠用了： Babel：自由開源的 JavaScript 編譯器、轉譯器。 Router：Vue 的路由。 Vuex：組件狀態管理。 關於怎麼裝 npm 和 vue-cli，我想 npm 就網上下載安裝，vue-cli 就執行 npm install -g @vue/cli 指令進行安裝。 vue create demo # 創建一個 vue-cli 應用 # 按下 Down 再按 Enter 選擇第二項自定義 Vue CLI v4.4.6 ? Please pick a preset: default (babel, eslint) ❯ Manually select features # 用空白鍵選擇下面的三個，並按 Enter ? Please pick a preset: Manually select features ? Check the features needed for your project: ◉ Babel ◯ TypeScript ◯ Progressive Web App (PWA) Support ❯◉ Router ◉ Vuex ◯ CSS Pre-processors ◯ Linter / Formatter ◯ Unit Testing ◯ E2E Testing 如果這裡沒有選擇裝 Router 和 Vuex 的話，沒關係，我這篇文章後面會教這兩個的基本使用也會教怎麼自己導入，畢竟幾個月前是需要自己另外裝的。感覺是被 npm 被 Github 合併之後變這麼方便。 後面的選項如果都沒特別需求就一直按 Enter 就好。 ","date":"2020-07-31","objectID":"/vue_skill/:2:1","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"Project 結構 . ├── babel.config.js ├── .browserslistrc ├── .git ├── .gitignore ├── node_modules ├── package.json ├── package-lock.json ├── public │ ├── favicon.ico │ └── index.html ├── README.md └── src ├── App.vue ├── assets │ └── logo.png ├── components │ └── HelloWorld.vue ├── main.js ├── router │ └── index.js ├── store │ └── index.js └── views ├── About.vue └── Home.vue 上面是創建完應用後會出現的 Project 結構。這裡 npm 真的很貼心，連 .git、.gitignore、README.md 都幫你新建好了。 這裡比較需要注意的是 package.json 和 src 目錄，package.json 可以幫助你查看當前依賴版本和管理依賴，所有安裝依賴都會放到 node_modules 資料夾，所以如果出現依賴問題就將 node_modules 砍了，然後重新執行 npm install 指令，如果要升級依賴套件就執行 npm update 就能一次更新 Project 中的所有套件。如果再有問題，建議直接將 Error 訊息用 Google 搜索一下，大部分解決辦法都在 Stack Overflow 和 Github issues 等地方找到解決辦法。 ","date":"2020-07-31","objectID":"/vue_skill/:2:2","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"src 目錄 檔案或文件 用途 App.vue 作為所有 SPA 頁面的起始根頁面 assets/ 靜態資源 e.g. CSS JS IMG components/ 自定義組件 main.js 作為所有 SPA 頁面的全局 JS 文件 router/ 路由配置文件 store/ Vuex 的狀態管理 views/ 頁面或子頁面 src 目錄是我們最主要寫項目時編輯的地方，目前最新版的 vue-cli 所生成的目錄長這樣（雖然之前不是這樣），總之用途都幫你分類好了。 ","date":"2020-07-31","objectID":"/vue_skill/:2:3","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"編寫習慣 1 引入依賴 引入依賴的判斷，通常如果只是單一個頁面或有特殊需求的頁面要引入使用一個組件，我會建議直接在這個頁面的 *.vue 直接引入註冊組件，如果是像是很多頁面都要用的組件就需要在 main.js 全局引入註冊組件，e.g. UI 庫框架。 2 Components 與 Views 的區別 通常我很少會去動 Components 這目錄，除非需要我自己寫組件，雖然 Components 和 Views 裡面裝的 *.vue 都是組件，但最大的區別是Components 是不具有配置 router 的一般組件，Views 裡面是有配置 router 的子組件，所以在頁面跳轉時我們會是跳轉到 Views 目錄下的組件。 3 子頁面 註：不管哪個頁面，源碼中 \u003ctemplate\u003e\u003c/template\u003e 裡面中必須先用一個 \u003cdiv\u003e\u003c/div\u003e 往裡面包一層，因為只能有一個根父元素。 有些人會使用一般的組件然後用 v-if 或 v-on 判斷作為子頁面顯示，我是不建議這樣子做，因為這樣的頁面如果點了一下瀏覽器刷新頁面，所有頁面當前位置都會被重置，e.g 如果你有個頁面 Nav 上有購物車和商店，如果你購物車和商店的子頁面是上述所說的沒配置不具備路由屬性，在網址 URL 上相同都是 https://localhost:8080/，你刷新頁面整個頁面就會初始化，如果是有配置路由的子頁面會分別像是 https://localhost:8080/cart 和 https://localhost:8080/home，這樣才能保證你當前檢視的頁面刷新網址後不會改變目前正在檢視子頁面。 4 關於是否需要用到 JQuery 或是其他前端 JS 框架 我一開始也會有這樣的疑惑，明明用了 Vue 會試著想去混著使用 JQuery，但現在我的建議很明確，沒必要混著用，兩者都是可以用自己的方式實現相關功能，像是 Vue 網上就有豐富的組件庫，JQuery 勢必是會被淘汰的產物。比如說好了，像是之前我要做一個點擊按鈕頁面滑動到特定 #id 元素的效果，而我一開始死命去找 Vue 有沒有相關 JS 代碼實現，然後卻一直找不到，自己用純 Js 實現也報錯，Google 搜到的大多都是 JQuery 實現，後面我發現原來是我沒用好 Keyword 去搜，其實是有相關組件實現的。 5 關於組件之間的傳值 直接說結論：Vuex 去管理，網上會看到很多人教 Vue 使用一定會教怎麼父子組件互相傳值，我一開始也是用這方法傳值，但是當你使用的是子頁面 router 時，恰好這些父子組件傳值根本沒用，你只能用 query string 傳參，但是這樣只能傳一個參數，所以除非是你要自己寫組件給別人或自己設計組件用，不然是不需要用到父子組件傳值方式，相對的使用 Vuex 才是更為方便的方式。 6 Vuex 使用的場景 目前使用 Vuex 最大需要注意的點是如果你點擊瀏覽器刷新頁面，所有的 State 都會被初始化，所以不能只依據 Vuex 去存數據，像是 Jwt token 應該放在 localsStorage 或 Cookie，每個頁面在初始化時就要異步請求數據，也就是每刷新一次頁面就會請求一次或多次數據，這是必須的，沒有簡便的方法，Vuex 侷限性也很多，一般我是建議將請求的 URL 存在 Vuex 的 State，如果後端改了 URL 前端也好一次搞好所有請求 URL，加上一個請求可能需要在多個子頁面中會使用到，為了增加複用性和方便，HTTP 請求 URL 用 Vuex 引入。 7 請求 我自己寫前端 HTTP 請求都是寫異步請求，至於後端要怎樣的請求方式，前端真的無法決定，只是如果是需要測試數據，我建議是使用 MockJS 作為前端測試數據用，這樣也不需要前端一直填測試數據，被後端侷限。這篇文章後面我會寫一下 Axios 請求的方式。 8 Static Source 既然我們要寫 CSS Style，那我們就要統一使用 Class 或 Id 去編寫元素樣式，Inline Style 並不好加以管理，也不好發現錯誤，有時摳 CSS 摳不出自己想要的效果會讓我很煩躁。 9 駝峰命名法與註解 這部份應該不用我多說明，除了這些，你的 Code 也需要規範化，變量命名也需要有意義，不是純粹的英文字母。Code 的易讀性真的很重要。 10 CSS Position Fixed 我相信有些頁面經常會用 Fixed 來固定某些元素，然而在這部份，我是建議要盡可能的少使用這方法，因為在排版上，如果沒有指定特定的長寬，會造成走版， 11 export default 與 new Vue 相信一開始都有人有這問題，當然網上搜也是一大把結果，我就在這裡簡略說一下： new Vue：這是應用程序的根 Vue 實例。 new Vue({ el: '#app', data () { return {} } }) \u003chtml\u003e ... \u003cbody\u003e \u003cdiv id=\"app\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e export default：ES6 語法中的導出，也就是說這是聲明一個之後會被註冊使用的組件，創建一個本地可註冊的 Vue 組件。 // my-component.js export default { name: 'my-component', data () { return {} } } \u003c!-- another-component.js --\u003e \u003ctemplate\u003e \u003cmy-component\u003e\u003c/my-component\u003e \u003c/template\u003e \u003cscript\u003e import myComponent from 'my-component' export default { components: { myComponent }, data () { return {} } // ... } \u003c/script\u003e 12 調試端口 Port 一般預設調適端口是 8080，但有時也不是這樣，不過這部份也沒有什麼好改動的，畢竟後端也不需要知道前端是哪個 URL 發送的請求，除非自己有什麼強迫症非要改調試時的 Websocket 端口，不然沒必要去在意。這裡姑且還是寫一下改動調適端口的寫法。 在 demo/（也就是 Project 根目錄）下新建一個 vue.config.js 檔案，並寫入下列內容。 // vue.config.js module.exports = { devServer: { // 告訴 dev-server 在服務器啟動後打開瀏覽器，將其設置 true 為打開默認瀏覽器 open: true, // 運行的 host 和 port host: 'localhost', port: 8080, } } 13 Assets 與 Static 大家都會疑惑 Assets 與 Static 都是放靜態資源的目錄，但為什麼要有兩個？區別如下： Assets：在運行 npm run build 之後會隨著打包後進行資源壓縮體積，Code 格式化，打包完會生成放在 static/ 中隨 index.html 一起部署到服務器。 Static：打包時不會走打包的壓縮流程，打包效率高，但不會進行壓縮也意味著資源佔用大，影響頁面載入速度。 所以有如下規則： 我們自己寫頁面需要的靜態資源放到 assets/ 目錄下。 第三方的 JS 靜態資源因為是別人經過處理的，所以可以放到 static/。 14 推薦的 UI 框架 我不會推薦 Vuetify，拜託不要被他絢麗的外貌所吸引，坑很多的，建議的是 Ant design、Bootstrap-vue、Buefy。 ","date":"2020-07-31","objectID":"/vue_skill/:2:4","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"Router Router 配置 安裝： npm install vue-router # 安裝 vue-router 配置說明： 如果沒有這些資料夾和檔案就自己新建。 如果你在一開始就有裝 Router，那你會在 src/router/index.js 發現如下內容，這裡引入 vue-router，並使用 Vue.use(VueRouter) 註冊該組件，然後聲明一個 routes 常量，並將 views/ 資料夾裡的組件引入到這裡且賦值給 routes Array Object。然後再賦值給一個 VueRouter Object，再導出該 Object，在 src/main.js 中引入。 註：引入的組件名稱可以自己定義，因為是 export default。ES6 語法中 import 和 export 可以有多個，但是 export default 只能有一個。 // src/router/index.js import Vue from 'vue' import VueRouter from 'vue-router' import Home from '../views/Home.vue' Vue.use(VueRouter) // 註冊陸游組件 // routes 常量 const routes = [ { path: '/', name: 'Home', component: Home }, { path: '/about', name: 'About', // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =\u003e import(/* webpackChunkName: \"about\" */ '../views/About.vue') } ] // VueRouter Object const router = new VueRouter({ mode: 'history', base: process.env.BASE_URL, routes }) // 導出 export default router // src/main.js import Vue from 'vue' import App from './App.vue' import router from './router' // 引入 router import store from './store' Vue.config.productionTip = false new Vue({ router, // 引入 store, render: h =\u003e h(App) }).$mount('#app') 在需要用道路由管理顯示的組件加入 \u003crouter-view/\u003e，\u003crouter-link\u003e\u003c/router-link\u003e 用於路由跳轉規則，就像一開始初始化的 src/App.vue： \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cdiv id=\"nav\"\u003e \u003crouter-link to=\"/\"\u003eHome\u003c/router-link\u003e | \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e \u003c/div\u003e \u003crouter-view/\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; } #nav { padding: 30px; } #nav a { font-weight: bold; color: #2c3e50; } #nav a.router-link-exact-active { color: #42b983; } \u003c/style\u003e Router 配置注意點 // 這裡 Home 組件是需要引入的，但是因為上面的例子有寫，這裡為了方便描述就不寫了 const routes = [ { path: '/', name: 'Home', component: Home }, { path: '/about', name: 'About', // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =\u003e import(/* webpackChunkName: \"about\" */ '../views/About.vue') } ] 首先就是 routes 這常量中的 Object 通常由 path、name、component 這些 Key 值所組成，分別代表的是：路徑、路由名、組件。如果 path: '/about'，在調試時就是 http://localhost:8080/about，name: 'About' 可以作為前端頁面路由跳轉時使用的判斷值，component 代表該路由所代表的組件，就是跳轉到該路由時會顯示的組件。 component 有兩種寫法：第一種是像上面例子中的 Home，直接賦值引入的組件，這種寫法，會在載入根頁面全部 JS 渲染完成。第二種是上面的 Home，懶加載，這種寫法可以避免如果頁面應用很大會花很久載入頁面（使用的是匿名函數），加載根頁面時會依據當前頁面所需要加載對應的 JS，不是當前頁面需要的不會在此加載。我是建議後者的寫法。 現在初始化路由時預設的 Router Mode 是 history，就是沒有錨點的方式，如果想要換回有錨點的可以改成 hash，但是我偏好是 history，這樣 URL 也比較乾淨。 子路由與重定向 我們可以給每個路由弄子路由，重定向就是如果跳轉到某個路由會特地跳到另一個路由，一般用於有多個子路由的對象，或是跳轉到 404 頁面，e.g. 註：父路由沒有一定需要有 component 的 value 值，也可以沒有。 const routes = [ { path: '/sign', name: 'Sign', component: () =\u003e import ( /* webpackChunkName: \"Sign\" */ '../views/sign/Sign.vue'), // 子路由 children: [{ path: '/sign/signIn', name: 'SignIn', component: () =\u003e import ( /* webpackChunkName: \"SignIn\" */ '../view/sign/SignIn.vue') }, { path: '/sign/signUp', name: 'SignUp', component: () =\u003e import ( /* webpackChunkName: \"SignUp\" */ '../view/sign/SignUp.vue') }, { path: '/sign/verifyEmail', name: 'VerifyEmail', component: () =\u003e import ( /* webpackChunkName: \"VerifyEmail\" */ '.views/sign/verifyEmail.vue') }, { path: '/sign/forgotPassword', name: 'ForgotPassword', component: () =\u003e import ( /* webpackChunkName: \"ForgotPassword\" */ '.views/sign/forgotPassword.vue') } ], //强制重定向 redirect: '/sign/signIn' }, ] 404 下面的寫法可以匹配 404 路由。 const routes = [ { path: '*', name: '404', component: () =\u003e import ( /* webpackChunkName: \"404\" */ '../views/error/pageNotFound.vue') } ] 動態路由 動態路由會攜帶一個參數，可以用來在初始化渲染組件時發送請求數據，會攜帶的參數代表的意義可以是 UserID 或是 UserName…等，e.g 像是 Github 在查看別人的空間時 URL 上會有使用者的 UserName，所以會根據那個參數請求數據。 const routes = [ { path: '/:id/admin', name: 'admin', component: () =\u003e import ( /* webpackChunkName: \"admin\" */ '../views/blog-admin/admin.vue'), children: [{ path","date":"2020-07-31","objectID":"/vue_skill/:2:5","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"Vuex 其實很多人一開始看 Vuex 的官方文檔看不懂，我也不意外，因為太晦澀了，看不懂。但是我在看完某個 B 站上的教學影片後，我開竅了，因為用文字很難描述清楚，建議這影片長度全部看完才能真正理解 Vuex，這裡奉上影片位置。 ","date":"2020-07-31","objectID":"/vue_skill/:2:6","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"Vue 的 Request 我使用 axios 前後端分離跨域請求數據。 安裝 npm i vue-axios 註冊組件 // src/main.js import Vue from 'vue' import axios from 'axios' import VueAxios from 'vue-axios' Vue.use(VueAxios, axios) 我通常使用三種方法請求： Params Form-data 放 Body 的純 Js 註：我會為了整齊與易用，會讓請求單獨放在一個獨立的 Function 作為異步請求使用，還有一個非常重要的點是 Axios 是異步的，所以不要在 Axios 請求 Code 後添加任何 Code Params import 'axios' from 'axios' export default { // ... methods: { // ... async checkEmail() { var params = new URLSearchParams(); params.append(\"email\", this.email); axios .post(this.checkSameEmailURL, params) .then(response =\u003e { console.log(response); console.log(response.data); if (response.data.data === false) { return false; } else { return true; } }) .catch(error =\u003e { console.log(error); }); } } } Form-data 這裡要換成這樣的寫法比較方便，這裡設置 Content-Type 為 'multipart/form-data'（'form-data' 也可以）。 import axios from 'axios' export default { // ... methods: { // ... async LoginRequest() { let data = new FormData(); data.append(\"email\", this.email); data.append(\"password\", this.password); axios .post(this.loginURL, data, { headers: { \"Content-Type\": \"form-data\" }, transformRequest: [(data, headers) =\u003e data], //預設值，不做任何轉換 }) .then((response) =\u003e { console.log(response); console.log(response.data); this.loginSuccess = response.data.data; this.openDialog = false; if (this.loginSuccess) { this.dialog = true; } }) .catch((error) =\u003e { console.log(error); this.openDialog = false; if (this.loginSuccess) { this.dialog = true; } }); } } } 純 Js import axios from 'axios' export default { // ... methods: { // ... async RegisterRequest() { axios({ method: \"post\", url: this.registerURL, headers: {}, data: { username: this.name, password: this.password, email: this.email, phone: this.phone, }, }) .then((response) =\u003e { console.log(response.data); this.registerSuccess = response.data.data; this.openDialog = false; this.dialog = true; }) .catch((error) =\u003e { console.log(error); }); }, } } Header 帶 Token 的請求 下面的例子中，在 header 添加 Authorization 參數，這裡要注意的是 header 與 data 的參數位置，不管 data 裡面有沒有內容，即使是空的也要添加上去。 import axios from 'axios' export default { // ... methods: { // ... async getAllChannels() { // 初始化 this.showChannels = []; let jwt_token = Vue.localStorage.get(\"jwt_token\"); let UserID = Vue.localStorage.get(\"user_id\"); let data = new FormData(); data.append(\"id\", UserID); axios .post(this.requestGetAllChannelsURL, data, { headers: { \"Content-Type\": \"form-data\", Authorization: `Bearer ${jwt_token}`, }, transformRequest: [(headers) =\u003e data], //預設值，不做任何轉換 }) .then((response) =\u003e { console.log(response.data); if (response.data.data === undefined) { // token 失效 // 移除 token 和 id Vue.localStorage.remove(\"jwt_token\"); Vue.localStorage.remove(\"user_id\"); // 重新登入 document.location.href = \"/\"; } else if (response.data.data) { // 有找到數據 this.showChannels = response.data.channels; // 推入 VueX this.$store.commit(UPDATE_ALL_CHANNELS, response.data.channels); console.log(this.showChannels); console.log(response.data.channels); // 請求 channel 的 message 並存入 VueX for (let i = 0; i \u003c this.showChannels.length; i++) { this.getAllMessage(this.showChannels[i].id); } } else { // 沒找到數據 } }) .catch((error) =\u003e { console.log(error); }); }, } } ","date":"2020-07-31","objectID":"/vue_skill/:2:7","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"多頁面應用 應用場景 多頁面應用的概念就是如果你的 Web 網頁想要有多個面向不同需求的應用，或是想要將 PC 端和手機端的分開設計，想做不同風格的頁面，就可以使用多頁面應用實現。Web 端有不同需求的意思是假設你要做一個電商平台，卻又想要建一個社區論壇，這時就是不同的需求，需要使用多頁面應用。 多頁面應用配置 在 Project 根目錄的 vue.config.js 添加以下內容： 需要修改的地方是 devServer 配置首頁入口，改成自己要的。 let path = require('path') let glob = require('glob') // 用于筛选文件 // 工厂函数 - 配置pages实现多页面获取某文件夹下的html与js function handleEntry(entry) { let entries = {} let entryBaseName = '' let entryPathName = '' let entryTemplate = '' let applicationName = '' glob.sync(entry).forEach(item =\u003e { console.log('!!!', item) entryBaseName = path.basename(item, path.extname(item)) console.log('entryBaseName:', entryBaseName) entryTemplate = item.split('/').splice(-3) console.log('entryTemplate:', entryTemplate) entryPathName = entryBaseName // 正确输出js和html的路径 console.log('entryPathName', entryPathName) entries[entryPathName] = { entry: 'src/' + entryTemplate[0] + '/' + entryTemplate[1] + '/' + entryTemplate[1] + '.js', template: 'src/' + entryTemplate[0] + '/' + entryTemplate[1] + '/' + entryTemplate[2], title: entryTemplate[2], filename: entryTemplate[2] } }) return entries } let pages = handleEntry('./src/application/**?/*.html') console.log(pages) // 以下开始配置 module.exports = { // 引入 vuetify \"transpileDependencies\": [ \"vuetify\" ], lintOnSave: false, // 关掉eslint /** * baseUrl 从 3.3 起废用，使用 pubilcPath 代替 * 默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上，例如 https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 https://www.my-app.com/my-app/，则设置 publicPath 为 /my-app/。 * 这个值也可以被设置为空字符串 ('') 或是相对路径 ('./')，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。 */ publicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"/\", productionSourceMap: false, // 入口设置 pages, devServer: { index: '/', // 运行时，默认打开application1页面 // 告诉dev-server在服务器启动后打开浏览器，将其设置true为打开默认浏览器 open: true, // host: 'localhost', // port: 8080, // https: false, hotOnly: false, // 配置首页 入口链接 before: app =\u003e { app.get('/', (req, res, next) =\u003e { for (let i in pages) { //res.write(`\u003ca target=\"_self\" href=\"/${i}\"\u003e/${i}\u003c/a\u003e\u003c/br\u003e`); if (i === 'introduce') { res.write(`\u003cscript\u003edocument.location.href=\"/${i}\";\u003c/script\u003e`); } } res.end() }); }, // proxy: { //配置跨域 // '/api': { // target: 'https://sm.ms/api/upload', //這裡後台的地址模擬的，應該填寫真實的後台api // ws: false, // 如果要代理 websockets // changOrigin: true, //允許跨域 // pathRewrite: { // '^/api': '' //請求的時候使用這個api就可以 // } // } // } }, } 接著弄多頁面應用的時候，在 src/ 下新建一個 application/ 目錄，然後如果我要新增的是電商平台寵物商店和論壇，應用名稱分別為 PetStore 和 Communication，就改造成如下目錄結構： . ├── babel.config.js ├── .browserslistrc ├── .git ├── .gitignore ├── node_modules ├── package.json ├── package-lock.json ├── public │ ├── favicon.ico │ └── index.html ├── README.md ├── src │ ├── PetStore │ │ ├── assets │ │ │ └── index.js │ │ ├── components │ │ │ └── HelloWorld.vue │ │ ├── router │ │ │ └── index.js │ │ ├── store │ │ │ └── index.js │ │ ├── views │ │ │ ├── About.vue │ │ │ └── Home.vue │ │ ├── PetStore.html │ │ ├── PetStore.js │ │ └── PetStore.vue │ └── Communication │ ├── assets │ │ └── index.js │ ├── components │ │ └── HelloWorld.vue │ ├── router │ │ └── index.js │ ├── store │ │ └── index.js │ ├── views │ │ ├── About.vue │ │ └── Home.vue │ ├── Communication.html │ ├── Communication.js │ └── Communication.vue └── vue.config.js 上面的 src/ 下就是將整個 SPA 單頁面應用重新整合成多頁面應用。PetStore.html 對應的內容是重構前的 public/index.html、PetStore.js 對應的是 src/main.js、PetStore.vue 對應的是 src/App.vue。 配置注意點 根據在 src/application 下的所有頁面應用中的所有的目錄名稱還有作為根組件的相關 File 名稱要跟頁面應用名稱一模一樣，因為在 vue.config.js 中的遍歷函數會用這樣的規則遍歷，如果想要改的話可以自己改。 這樣子配置之後，Project 根目錄中 public/ 相當於不會影響項目的目錄，當然要放靜態資源也是可以。 在 /public 同個圖片不能在不同的應用中使用。這部份我確認過，不知道是不是 Bug。 ","date":"2020-07-31","objectID":"/vue_skill/:2:8","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"常見的問題 引入圖片 有時我們要用 js 引入相對位置圖片會失敗，像下面的例子： \u003ctemplate\u003e \u003cdiv\u003e \u003cimg :src=\"img\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { img: \"../assets/image/xxxxx.png\" } } } \u003c/script\u003e 之所以會失敗是因為，網頁把根域名當作相對路徑的根目錄，上面的 img: \"../assets/image/xxxxx.png\" 被識別為 img: \"http://localhost:8080/../assets/image/xxxxx.png\"，應該要改成如下方法 \u003ctemplate\u003e \u003cdiv\u003e \u003cimg :src=\"img\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { img: require(\"../assets/image/xxxxx.png\") } } } \u003c/script\u003e ","date":"2020-07-31","objectID":"/vue_skill/:2:9","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"部署 關於部署，最後 Project 根目錄執行 npm run build，就能夠編譯生成最後的成品，就是 dist/ 目錄的生成，將 dist/ 目錄提出來部署到 Github Pages、Herokuv 或 Docker。 部署 - Vue CLI ","date":"2020-07-31","objectID":"/vue_skill/:2:10","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"關於 NuxtJS NuxtJS 是 Vue-cli 的簡化集合版，也就是如果你很懶，你可以用 NuxtJS，但是運行起來的速度可想而知，真的很慢。如果想要在開發調試時好一些，建議就用 Vue-cli。 ","date":"2020-07-31","objectID":"/vue_skill/:3:0","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"關於用 Vue 寫桌面應用和 Android 端 Vue 寫桌面應用是 Electron-vue，寫 Android 是 Vue Native。然而，不要嘗試使用任何 HTML 語言寫桌面應用和 Android 端，因為真的不如原生性能好，現在大前端（使用一種技術實現多種平台的前端）還不夠成熟，我想起我之前調試 Electron-vue 的恐懼，不知道多少次記憶體佔滿，強制關機 (´;ω;`) ","date":"2020-07-31","objectID":"/vue_skill/:4:0","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["前端"],"content":"Reference Vue Router vue的export default 還是沒能理解它是什麼 - IT 邦幫忙 Vue ‘export default’ vs ‘new Vue’ - stack overflow Vue状态管理-Vuex简要教程 - BiliBili vue-axios - npm VUE.CLI 4.0 配置多页面入口礼包送你！ - 掘金 部署 - Vue CLI vue中assets和static的區別 Vue中img的src属性绑定与static文件夹 - 簡書 ","date":"2020-07-31","objectID":"/vue_skill/:5:0","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios"],"title":"VUE 技巧與經驗","uri":"/vue_skill/"},{"categories":["Moment"],"content":"感觸 我第一次接觸 Hugo 的時候，是我因為朋友的技術 Blog 所以感興趣，尤其因為當時剛開始接觸項目和比賽，所以學了 Git 和 Markdown 卻不熟練，笨手笨腳的，那時大一生的我實在是太菜了，現在想想已經過了兩年，已經到了升上大三，時光飛逝，年紀越大感觸越深。 我第一次學怎麼構建 Hugo + Github Pages 構建自己的 Blog 是看這篇文章，這篇文章真的寫得很好，我也推薦我室友看這篇文章，他也快速就上手了。我還記得當時我真的就是折騰在 Hugo 主題上，我第一次選的主題無法發表 Posts，是比較適合拿來做簡歷的主題，害我白搞了一天要換主題，第二次看中了 AllinOne 主題（不知道位為什麼現在這主題從 Hugo Theme 網站下架了），因為看這主題很酷炫，但這主題說真的配置起來很麻煩，最後配置完還發現手機端的顯示不正常，要自己去修 CSS，還有各種 Bug。 最近又因為發現自己很多文章中上傳到圖床的圖片很多被 404 了，我也不知道為什麼被 SM.MS 給 Block 了，加上我 AllinOne 這主題讓我的 Blog 載入速度過慢，直到前幾天，我經過好友的建議，終於決定要全面換新，我也考慮要換哪個主題找好久，好友推薦我 LoveIt 這主題，我也最終被這主題的界面打動，決定改用這個主題，一開始摸索這主題的配置參數弄了很久，加上這個主題沒有正體中文的界面，所以我自己去修 i18n 的文件內容，把自己所有文章的構造重新整理一次，將自己所有的文章要用圖片都使用 Tinypng 壓縮過再上傳到 imgpoi，最終成了現在的樣子。我很滿意 (,,・ω・,,) Rem BlogRemBlog.png \" Rem Blog ","date":"2020-07-31","objectID":"/hugo_theme_change/:1:0","tags":["Hugo","Theme","LoveIt","AllinOne","Blog"],"title":"Rem Blog 的構造改革過程心得","uri":"/hugo_theme_change/"},{"categories":["Moment"],"content":"Reference AllinOne LoveIt ","date":"2020-07-31","objectID":"/hugo_theme_change/:2:0","tags":["Hugo","Theme","LoveIt","AllinOne","Blog"],"title":"Rem Blog 的構造改革過程心得","uri":"/hugo_theme_change/"},{"categories":["Python"],"content":"前言 因為我家人正在學習寫 Python，我教導他去刷題庫，結果在高中生解題系統要解某個基礎題庫的題目時卡住了，我只好幫他解一下題目。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:1:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"題目 這是高中生解題系統基礎題庫裡的 a013 題目 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"內容 如果生活在數世紀之前的古羅馬，你應該用過 V 來表示五。V 和 5 這兩個符號都可以用來表示數目五。用來表示數目的符號稱作數字。而羅馬人用來表示數目的符號就是羅馬數字。 以下是七個基本的羅馬數字︰ 羅馬數字 數目 I 1 V 5 X 10 L 50 C 100 D 500 M 1,000 所有其他的數目都是由這些數字組合而成。數目都是由左寫到右，通常值是等於組成的羅馬數字加起來。 例如十七可以表示為 X + V + I + I = XVII 10 + 5 + 1 + 1 = 17 表示羅馬數字可以使用減法來取代加法的規則。例如四可以不用四個一相加來表示 IIII，而採用五減一來表示 IV。利用這類規則，羅馬人能夠減化許多數目的表示方式，例如 IX 取代 VIIII 表示 9，及 CD 取代 CCCC 表示 400。 今日我們並不確定羅馬符號的起源為何。例如符號 V 的起源主要有兩個理論。有些學者認為五最早是用握拳、拇指在外的手勢來表示。最後以象形文字書寫而簡化為 V。 另一個理論認為 X 源自在 10 條線加上交叉線。因此五可以表示為 X 的一半，或是 V。 羅馬數字可以很容易地用來相加或相減，但算起乘除法就相當不順手。這就是為什麼現在羅馬數字並不常用的原因了。 問題 然而，羅馬數字還是經常用於書本章節及頁碼的編號。在這一題工作是讀入兩個正整數，然後輸出兩個數字差的絕對值。所有的數字都必須以羅馬數字來表示。而連續四個相同符號出現時，必須用減法規則來化簡之。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:1","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"問題 然而，羅馬數字還是經常用於書本章節及頁碼的編號。在這一題工作是讀入兩個正整數，然後輸出兩個數字差的絕對值。所有的數字都必須以羅馬數字來表示。而連續四個相同符號出現時，必須用減法規則來化簡之。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:2","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"輸入說明 每個輸入檔中會有一個或以上的測試資料。每一行由兩個數字組成一筆測試資料，且所有數字將會小於4,000。檔案最後會以符號 # 表示結束。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:3","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"輸出說明 每筆測試資料的答案必須輸出到檔案中，並且換行。如果答案為零，則須輸出字串 ZERO。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:4","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"測資資訊 記憶體限制： 512 MB 公開 測資點#0 (100%): 1.0s , \u003c1K ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:5","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"範例輸入輸出 Input I I MM II # Output ZERO MCMXCVIII ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:6","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"題目理解 首先我們仔細觀察輸出說明，雖然說要輸出到檔案，其實只要用 print() 輸出就好，然後根據測資，我們可以確定輸入輸出之間的 Code 是要我們寫羅馬數字相減後得到之差的絕對值，考我們羅馬數字與十進制數字之間的轉換，難度也沒用到什麼演算法，但是如果不熟悉就會出現邏輯錯誤。這題主要是可慮到細節的注意。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:3:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"程序設計思路 在轉換的過程要特別處理位數數字是 4 和 9 的位數，然後十進制轉換成羅馬數字時每個位數有不同的轉換標準，所以要另外聲明一個變量紀錄當前處理的位數。 當我們直觀將羅馬數字轉換成我們平常用的十進制數時，我們會從羅馬數字的尾部開始做計算轉換相加，所以我們在寫羅馬數字轉換成十進制數時，要先將羅馬數字字符串反轉（Reverse）。 Python 中 String 沒有 reverse() 方法，所以需要使用 string[::-1] 的方式轉換。 測資數字不超過 4000，所以不用考慮千位數上的 4 和 9。 羅馬數字轉成十進制數時為了 4 和 9 需要知道下一個字母是否比自己小，Python 對 Array 的 Index 會有 string index out of range 的問題，所以在處理前要用 If 判斷是否當前位數是否是字符串最後一個字符。 十進制數轉成羅馬數字時，需要注意一下如果位數數字是 0 的話就不做處理。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:4:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"Functions number_translate_rome(number)：十進制數轉成羅馬數字 rome_translate_number(rome)：羅馬數字轉成十進制 subtract(rome_list)：絕對值相減計算 main：主函式 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:5:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"流程 在 Main 函式中輸入一個字符串，並使用 String 中的 split() 方法進行分割出兩個羅馬數字，這裡需要使用 While 迴圈，並判斷如果輸入的字符串是 # 就中止循環。 兩個羅馬數字轉成 List 類型後傳入 subtract() 進行相減。 將兩數字利用 rome_translate_number() 都轉成十進制，相減取絕對值，將絕對值傳入 number_translate_rome() 轉成數字。 將計算結果傳回 Main 函式並輸出。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:6:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"源碼 我這裡都有寫好註解喔 Σ(*ﾟдﾟﾉ)ﾉ # 題源： # https://zerojudge.tw/ShowProblem?problemid=a013 # 羅馬數字 # 羅馬數字代表的意思 I = 1 V = 5 X = 10 L = 50 C = 100 D = 500 M = 1000 # 數字轉羅馬 # 注意 4 和 9 要特別處理 def number_translate_rome(number): # 如果相減是 0 if number == 0: return \"ZERO\" # 轉換的結果 rome = \"\" # 紀錄正在處理的位數 times = 0 while number \u003e 0: # 取最小位 temp = int(number % 10) number = int(number - temp) # 當前位數 +1 times += 1 # 不同位有不同的處理方法 # 個位數 if times == 1: if temp != 0: # 1 - 4 if (temp / 5) \u003c 1: # 4 if temp == 4: rome = \"IV\" + rome # 1 - 3 else: for i in range(int(temp)): rome = \"I\" + rome # 5 - 9 else: # 9 if temp == 9: rome = \"IX\" + rome # 5 - 8 else: x = \"V\" for i in range(int(temp % 5)): x += \"I\" rome = x + rome # 十位數 elif times == 2: if temp != 0: # 10 - 40 if (temp / 5) \u003c 1: # 40 if temp == 4: rome = \"XL\" + rome # 10 - 30 else: for i in range(int(temp)): rome = \"X\" + rome # 50 - 90 else: # 90 if temp == 9: rome = \"XC\" + rome # 50 - 80 else: x = \"L\" for i in range(int(temp % 5)): x += \"X\" rome = x + rome # 百位數 elif times == 3: if temp != 0: # 100 - 400 if (temp / 5) \u003c 1: # 400 CD if temp == 4: rome = \"CD\" + rome # 100 - 300 else: for i in range(int(temp)): rome = \"C\" + rome # 500 - 900 else: # 900 CM if temp == 9: rome = \"CM\" + rome # 500 - 800 else: x = \"D\" for i in range(int(temp % 5)): x += \"C\" rome = x + rome # 千位數 elif times == 4: if temp != 0: # 測資不超過 4000 for i in range(int(temp)): rome = \"M\" + rome else: pass number /= 10 return rome # 羅馬轉數字 # 考慮到 4 和 9 的減位 # 注意 要先將字符串反轉 羅馬數字要從尾部開始計算 def rome_translate_number(rome): # 轉換結果 number = 0 # print(rome) # 反轉 string rome = rome[::-1] # 用 for 迴圈 i = 0 while i \u003c len(rome): if rome[i] == \"I\": number += 1 elif rome[i] == \"V\": # 避免 string index out of range if i != len(rome) - 1: # 4 IV if rome[i + 1] == \"I\": number += 4 # 將 I 也納入這次計算字符，跳過下一個字符的檢測 i += 1 else: number += 5 else: number += 5 elif rome[i] == \"X\": # 避免 string index out of range if i != len(rome) - 1: # 9 IX if rome[i + 1] == \"I\": number += 9 # 將 I 也納入這次計算字符，跳過下一個字符的檢測 i += 1 else: number += 10 else: number += 10 elif rome[i] == \"L\": # 避免 string index out of range if i != len(rome) - 1: # 40 XL if rome[i + 1] == \"X\": number += 40 # 將 X 也納入這次計算字符，跳過下一個字符的檢測 i += 1 else: number += 50 else: number += 50 elif rome[i] == \"C\": # 避免 string index out of range if i != len(rome) - 1: # 90 XC if rome[i + 1] == \"X\": number += 90 # 將 X 也納入這次計算字符，跳過下一個字符的檢測 i += 1 else: number += 100 else: number += 100 elif rome[i] == \"D\": # 避免 string index out of range if i != len(rome) - 1: # 400 CD if rome[i + 1] == \"C\": number += 400 # 將 C 也納入這次計算字符，跳過下一個字符的檢測 i += 1 else: number += 500 else: number += 500 elif rome[i] == \"M\": # 避免 string index out of range if i != len(rome) - 1: # 900 CM if rome[i + 1] == \"C\": number += 900 # 將 C 也納入這次計算字符，跳過下一個字符的檢測 i += 1 else: # print(rome[i + 1]) number += 1000 else: number += 1000 else: pass # 下一個 i += 1 # print(number) return number # 相減運算 def subtract(rome_list): rome_list[0] = rome_translate_number(rome_list[0]) rome_list[1] = rome_translate_number(rome_list[1]) # print(\"rome_list : %d, %d\" % (rome_list[0], rome_list[1])) # 數字相減 num_result = rome_list[0] - \\ rome_list[1] if rome_list[0] \u003e rome_list[1] else rome_list[1] - rome_list[0] # print(\"num_result: %d\" % num_result) return number_translate_rome(num_result) if __name__ == '__main__': while True: rome = input() # 結束 if rome == \"#\": break # string 分割 rome_list = rome.split() # print(\"rome1 %s , rome2 %s\" % (rome_list[0], rome_list[1])) result = subtract(rome_list) # print(\"end result: %s\" % result) print(\"%s\" % result) ","date":"2020-07-30","objectID":"/python_rome_number_programming/:7:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"運行結果 運行結果1.png \" 運行結果 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:8:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"結論 其實我在高中剛接觸 Code 時，也寫過這題，當時怎麼寫就是寫不出來，明明測資輸入輸出都是正確的，我那時的邏輯思路沒有現在那麼好，現在因為接觸大量的 Code，所以寫 Code 都會具有強烈邏輯性和很多註解。祝各位也能順利解決這題，沒有你想像中的難。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:9:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"Reference 高中生解題系統 a013 題目 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:10:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Linux"],"content":"前言 npm（Node Package Manager）是 node 包管理器，是 Node.js 預設的、以 JavaScript 編寫的軟體套件管理系統。相信各位在開發 Vue 或是快應用等方面都會用到 npm，這裡我寫一下關於 npm 在 Linux 上的配置，因為在 Linux 使用 npm，因為在使用 npm 安裝套件時會發生權限不足問題還有下載源速度過慢，我將在這篇文章教大家如何配置 npm。 ","date":"2020-02-06","objectID":"/linux_npm_configuration/:1:0","tags":["ArchLinux","Linux","npm"],"title":"Linux 配置 npm","uri":"/linux_npm_configuration/"},{"categories":["Linux"],"content":"安裝 npm 裝 npm 時，會幫你也裝 nodeJS等相關依賴。 sudo pacman -S npm ","date":"2020-02-06","objectID":"/linux_npm_configuration/:2:0","tags":["ArchLinux","Linux","npm"],"title":"Linux 配置 npm","uri":"/linux_npm_configuration/"},{"categories":["Linux"],"content":"npm 本地化 在家目錄建立資料夾 mkdir ~/.npm-global 設置 npm 的目標資料夾 npm config set prefix '~/.npm-global' 加入本地環境變量 如果你有安裝使用 ZSH，也需要在 ~/.zshrc 引入環境變量。 vim ~/.profile # 編輯本地環境變量 vim ~/.zshrc 添加以下內容，如果沒有 ~/.profile 就自己新建。 export PATH=~/.npm-global/bin:$PATH # 加入的變量 重置環境變量 輸入以下指令後記得要重新登出登入電腦。 source ~/.profile source ~/.zshrc ","date":"2020-02-06","objectID":"/linux_npm_configuration/:3:0","tags":["ArchLinux","Linux","npm"],"title":"Linux 配置 npm","uri":"/linux_npm_configuration/"},{"categories":["Linux"],"content":"設置國內鏡像 在牆內使用國內鏡像資源會更方便。 淘寶源 # 臨時使用 # XXX 為你要安裝的套件代稱 npm --registry https://registry.npm.taobao.org install XXX # 永久使用 npm config set registry https://registry.npm.taobao.org cnpmjs 源 直接使用 cnpmjs 替代 npm。 # 透過淘寶源安裝 cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org 使用 cnpm： cnpm install XXX # XXX 為你要安裝的套件代稱 ","date":"2020-02-06","objectID":"/linux_npm_configuration/:4:0","tags":["ArchLinux","Linux","npm"],"title":"Linux 配置 npm","uri":"/linux_npm_configuration/"},{"categories":["Linux"],"content":"結論 蠻簡單的，各位別想太複雜。 ","date":"2020-02-06","objectID":"/linux_npm_configuration/:5:0","tags":["ArchLinux","Linux","npm"],"title":"Linux 配置 npm","uri":"/linux_npm_configuration/"},{"categories":["Linux"],"content":"Reference Resolving EACCES permissions errors when installing packages globally - npmjs npm配置国内镜像资源+淘宝镜像 - CSDN ","date":"2020-02-06","objectID":"/linux_npm_configuration/:6:0","tags":["ArchLinux","Linux","npm"],"title":"Linux 配置 npm","uri":"/linux_npm_configuration/"},{"categories":["ArchLinux"],"content":"前言 這次之所以會有本次教學，是因為我大二上參加 2019 服創比賽，因為快應用開發 IDE 只有 *.deb 的 Ubuntu 版本，我當時將 *.deb 轉成 tar.gz 適用 Arch 發行版的包失敗，當時我是看這網站使用 Debtap 工具，雖然最後成功轉成 tar.gz，但是安裝時卻輸出該包的結構損壞，我也有在網上看到有建議 dkpg，然而實際上寫 PKGBUILD 才是最好的方法，當時是我朋友將快應用的官方 IDE 打包到 AUR 上，最後安裝成功，打包中途他也遇到很多坑，最後他寫了一篇 Arch Linux 打包教學，但他這篇卻沒有給出實例，讓大多數第一次打包的人看不懂，就跟看官方文檔一樣。網上詳細優質的打包教學少之又少，這次我藉著一個機會體會到打包的過程，為了紀錄這過程，我寫了這篇教學。 本次文章參考了 ArchWiki 的 Creating packages (简体中文)、PKGBUILD (简体中文) 和書術方隅。你可以認為我這篇是這三篇的綜合進化版。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:1:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"簡述 創建 PKGBUILD – 一個包創建描述文件，由 makepkg 使用來從原始碼創建二進位制包。Arch 套裝軟體標準包含當前規則和提高套裝軟體質量的方法。如果已經有了 PKGBUILD 文件，請參考 makepkg (簡體中文)。 打包前一定要先 Google 一下你要打包的軟體包是不是已經有人上傳到 AUR 了。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:2:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"準備工作 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:3:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"必需的軟體包 首先，確定你已安裝必須的工具包。安裝 base-devel 應該足夠了；它包含 make 和 makepkg 其它一些從原始碼編譯時所需要的工具。 創建包的一個很重要的工具是 makepkg（由 pacman 提供），它主要做以下工作： 檢查相關依賴是否安裝。 從指定的伺服器下載源文件。 解壓源文件。 編譯軟體並將它安裝於偽 root 環境下。 刪除二進位制文件和庫文件的符號連接。 生成包的 meta 文件。 將偽 root 環境壓縮成一個包文件。 將生成的包文件保存到配置的文件夾中（預設為當前工作目錄）。 sudo pacman -S base-devel # 安裝 base-devel ","date":"2020-01-31","objectID":"/archlinux_makepkg/:3:1","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"下載與測試安裝 - 觀察紀錄 下載你想打包的軟體的原始碼壓縮包，解壓，按照作者所說的步驟安裝它。記錄下在編譯和安裝軟體過程中需要的所有命令或步驟。你將要在 PKGBUILD文件中重複這些命令和步驟。 大多數軟體作者遵循三步走的安裝慣例： ./configure make make install 註：這裡的意思是要你將包下載下來按照作者寫的使用說明試安裝這個包，並紀錄這個包的所有安裝指令與步驟。因為我們後面會在寫 PKGBUILD 裡面用到這些。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:3:2","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"創建PKGBUILD 當你運行 makepkg 時，它會在當前工作目錄尋找一個 PKGBUILD 文件。如果找到 PKGBUILD 文件，它會下載該軟體的原始碼，根據 PKGBUILD 文件中的指令編譯它。PKGBUILD 中的指令必須能完全被 Bash 解釋。成功完成後，最後的二進位制文件和包的元訊息（即包的版本、依賴）被一起打包在 pkgname.pkg.tar.xz 文件包中，這個文件包可以使用 pacman -U \u003cpackage file\u003e 來安裝。 要開始製作一個包，你應該先創建一個空工作目錄，進入該目錄，創建一個 PKGBUILD 文件。 註：假設我是在 ~ 新建工作資料夾名為 work 作為工作目錄。 cd ~ # 進入家目錄 mkdir work # 新增 work 資料夾 cd work/ # 進入 work 資料夾 touch PKGBUILD # 新增 PKGBUILG ","date":"2020-01-31","objectID":"/archlinux_makepkg/:4:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"依樣畫葫蘆 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:5:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"模板 你可以複製 PKGBUILD 模板（位於 /usr/share/pacman/）到工作目錄，或者複製一個類似包的 PKGBUILD 也可以。如果你只想在別人的基礎上更改一些選項的話，後一種方法比較方便。 在 /usr/share/pacman/ 裡面有三份模板： 查看 PKGBUILD 模板1.png \" 查看 PKGBUILD 模板 PKGBUILD.proto: 經典原型。 PKGBUILD-split.proto: 分包原型。 PKGBUILD-vcs.proto: 如果你要打包的軟體原始碼上源來自 Git, SVN, Mercurial 這類版本控制系統(Version control systems, VCS)，請參考這份原型作為基礎。 我是直接將 PKGBUILD.proto 的內容複製然後貼到我的 ~/work/PKGBUILD 裡面，然後參考別人寫的 PKGBUILD。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:5:1","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"AUR PKGBUILD 範例 AUR 上有很用使用者上傳的包，可以參考他們寫的 PKGBUILD，這樣可以省去很多錯誤的寫法。在頁面的右側通常找一找都能找到。我就在這裡舉一些例子。 AUR 上的 PKGBUILD 範例02.png \" AUR 上的 PKGBUILD 範例 Upstream 包源是 .tar.xz kate Upstream 包源是 .deb quickapp-ide Upstream 源是零散文件 code 需要用 wine 模擬的軟體 foobar2000 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:5:2","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"編寫 PKGBUILD 下面是我 usr/share/pacman/PKGBUILD.proto 的內容。 # This is an example PKGBUILD file. Use this as a start to creating your own, # and remove these comments. For more information, see 'man PKGBUILD'. # NOTE: Please fill out the license field for your package! If it is unknown, # then please put 'unknown'. # Maintainer: Your Name \u003cyouremail@domain.com\u003e pkgname=NAME pkgver=VERSION pkgrel=1 epoch= pkgdesc=\"\" arch=() url=\"\" license=('GPL') groups=() depends=() makedepends=() checkdepends=() optdepends=() provides=() conflicts=() replaces=() backup=() options=() install= changelog= source=(\"$pkgname-$pkgver.tar.gz\" \"$pkgname-$pkgver.patch\") noextract=() md5sums=() validpgpkeys=() prepare() { cd \"$pkgname-$pkgver\" patch -p1 -i \"$srcdir/$pkgname-$pkgver.patch\" } build() { cd \"$pkgname-$pkgver\" ./configure --prefix=/usr make } check() { cd \"$pkgname-$pkgver\" make -k check } package() { cd \"$pkgname-$pkgver\" make DESTDIR=\"$pkgdir/\" install } ","date":"2020-01-31","objectID":"/archlinux_makepkg/:6:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"PKGBUILD 通常需要修改的屬性變量 註：在修改變量時，如果覺得有些變量不知道怎麼填，像是 depends，你不知道這軟體需要哪些依賴，這個時候你需要查看一下他們說明文檔，也或者有些軟體包下載下來後 解壓會有相關說明文檔，像我就直接將我下下來的 *.deb 解壓，查看裡面的說明文件。 pkgname：套件的名稱，由小寫字母、數字和下面字符組成：@ . _ + -，不能以符號作為開頭。軟體名稱應要與來源壓縮檔相符。e.g. 檔名叫做 kate-19.12.1.tar.xz，則 pkgname=kate。 pkgver：套件版本，應與上游作者發行版本一致，可包含字母、數字、日期、下劃線，但不可包含連字符號(-)，如果有請替換成下劃線。e.g. pkgver=2.5、pkgver=2_5.5。 pkgrel：釋出號，一個正整數，當同個套件版本的 PKGBUILD 更新，釋出號增加 1，當套件發佈新版本時，釋出號重置 1。 pkgdesc：套件的描述，建議少於 80 字符，建議不要使用套件名稱，除非安裝的套件名稱與該應用程式名稱不同。可以填中文。e.g. pkgdesc=\"The Open Source build of Visual Studio Code (vscode) editor\"。 arch：應用程式支援的架構，Arch 官方僅支援 x86_64。 url：套件的上源發佈網址。e.g. url=\"https://www.quickapp.cn/docCenter/IDEPublicity\"。 license：該軟體、套件採用的發佈許可證，在 [core] 的 license 包中有常用的許可證，安裝後可在 /usr/share/licenses/common 找到這些許可證協議，如果套件使用的許可證是裡面其中一個，這個值應該被設為許可證的目錄名稱，如果套件使用的許可證沒有在裡面，值設為 custom。關於 license 詳細寫部份我在後面會補充說明。 depends：套件執行時所需的依賴列表，可以用比較運算符來限制依賴版本，如：depends=('foobar\u003e=1.8.0')，不需要列出二次依賴，舉例來說，gtk2 依賴 glibc 和 glib2，而 glib2 本來就依賴 glibc，glibc 就不用加入依賴列表。e.g. depends=(fontconfig libxtst gtk3 python cairo alsa-lib nss gcc-libs libnotify libxss 'glibc\u003e=2.28-4' lsof which)。 outdepends：不影響軟體主要功能，提供額外特性的軟體包，要簡要說明每個包提供的功能。e.g. optdepends=( 'cups: printing support' 'sane: scanners support' 'libgphoto2: digital cameras support' 'alsa-lib: sound support' 'giflib: GIF images support' 'libjpeg: JPEG images support' 'libpng: PNG images support' ) makedepends：編譯時所需的依賴，可以像 depends 指定依賴版本，編譯時會將 depends 的軟體包預設作為編譯依賴，使用 makepkg 構件時 base-devel 視為已安裝，base-devel 的成員不應該出現在列表中，可用下面指令檢查一個依賴關係是否已存在 base-devel 中。 LC_ALL=C pacman -Si $(pactree -rl ''package'') 2\u003e/dev/null | grep -q \"^Groups *:.*base-devel\" source：構件軟體的來源，通常是 HTTP 或 FTP 網址，可以調用前面的 pkgname 和 pkgver，就是需要填這軟體的下載源，其中包含了這軟件包的 license 檔案源，e.g. quickapp-ide 的下載源是 \"https://statres.quickapp.cn/quickapp/ide/quickapp-ide-1.5.0.deb\" license 檔案在 https://statres.quickapp.cn/quickapp/quickapp/201809/file/201809171830002525474.docx 所以我們應該在 source 填上： source=( \"https://statres.quickapp.cn/quickapp/ide/${pkgname}-${pkgver}.deb\" \"https://statres.quickapp.cn/quickapp/quickapp/201809/file/201809171830002525474.docx\" ) md5sums/sha1sums/sha256sums：source 所列檔案校驗和，不需要自己填寫，用 updpkgsums 產生，或是用 makepkg -g \u003e\u003e PKGBUILD 產生。這階段還不需要輸入該指令。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:6:1","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"PKGBUILD 變數 makepkg 定義了兩個變數，在寫構建、安裝過程指令中會用到，在 packge() 函數中用的多。 srcdir makepkg 會將來源檔案解壓縮到這個目錄，或著在此目錄產生指向 PKGBUILD 中 source 陣列中的軟連結。 pkgdir makepkg 會把此目錄當作系統根目錄，將軟體安裝在此目錄下。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:6:2","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"PKGBUILD 通常需要修改的函數 當構建一個軟體包，如果 PKGBUILD 有定義下面五個函數，makepkg 將會觸發它們，而 package() 是必須被定義的，其他沒定義的函數在構建時將會跳過。 prepare() 用來執行構建來源的指令，此函數執行在 build() 之前，軟體包解壓之後，可以用 makepkg --noextract 跳過此函數執行。通常是建立資料夾和解壓下載下來的軟體包。 pkgver() 構件 VSC 軟體包時，軟體的版本可能每隔幾小時就更新，這時用 pkgver()。 build() 這個函數使用通用 Bash 指令編譯軟體並建立軟體安裝目錄，在 build() 的第一步就是進入解壓縮原始碼後的目錄。makepkg 會在執行 build() 前進入 $srcdir，大多情況第一條指令是： cd \"$srcdir/$pkgname-$pkgver\" 接下來編寫編譯要用到的指令，build() 會在 fakeroot 環境下執行，如果你要打包的軟體使用到了配置指令碼 (configure script)，使用參數 --prefix=/usr 是個好習慣，很多軟體在手動編譯安裝的時候會安裝到 /usr/local，但所有的 Arch 包應該安裝到 /usr 目錄。 ./configure --prefix=/usr make check() 用來執行 make check 或其他例行測試的地方，建議用 check() 去檢查軟體是否正確編譯且能正常執行。 若使用者不需要這步可以在 PKGBUILD/makepkg.conf 加入 BUILDENV+=('!check') 禁用，或是在執行 makepkg 加上參數 --nocheck。 package() 最後一步就是把編譯好的檔案放到一個目錄讓 makepkg 可以檢索並打包，這個目錄通常是 pkg，一個 fakeroot 環境，pkg 目錄複製了軟體安裝根目錄的階層關係，如果你手動放置了一個檔案到根目錄，那你也要把檔案放在 pkg 中相同的層級結構中，假設你想要把檔案安裝到 /usr/bin，在 fakeroot 環境中對應的路徑應該是 $pkgdir/usr/bin，極少情況會需要使用者手動去安裝檔案，一般情況使用 make install 即可將軟體安裝到正確的路徑，最後一行通常這樣寫： make DESTDIR=\"$pkgdir/\" install makepkg --repackage 只執行 package()，不執行 build()，如果僅修改包的依賴可以用這個指令重新打包以節省時間。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:6:3","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"補充 deb 包 關於 *.deb 寫 PKGBUILD 時不需要寫 check() 和 build()，因為 *.deb 本身就是二進制包，所以不需要再編譯成二進制包。 license 關於 license 我獨立出來補充說明，通常關於該軟體的 license 可以在該 Upstream（包源）找的到，或是下載下來的軟體包說明文件裡有，如果作者沒有寫 license 就不能隨意上傳 AUR，然後如果你要上傳的軟體包的 license 屬性在 /usr/share/licenses/common 可以找到，則將其值設為該值，e.g. 我有一個準備要上傳的包裡面的作者說明的 license 填的是 GPL，我就只要在那欄填寫 GPL，有多個 license 就填多個，像是 license=('GPT' 'LGPL' 'FDL')，然後 不需要將該 license 下載下來，也就是填寫 source 的時候不需要將 license 源填上去，再次強調不需要下載下來，除非 /usr/share/licenses/common 找不到跟該軟體包相符的 license 時候才需要在 source 填寫 license 檔案源，並在後面將 license 下載下來，接著 license 那欄寫 custom。 # 通用許可證 $ ls /usr/share/licenses/common AGPL APACHE CCPL EPL FDL1.3 GPL3 LGPL3 MPL2 PSF W3C AGPL3 Artistic2.0 CDDL FDL GPL LGPL LPPL PerlArtistic RUBY ZPL Apache Boost CPL FDL1.2 GPL2 LGPL2.1 MPL PHP Unlicense 如果你的 license 需要下載下來，則授權要安裝到 /usr/share/licenses/pkgname/，把下面指令寫入 PKGBUILD 的 package()： install -Dm 644 LICENSE \"$pkgdir/usr/share/licenses/$pkgname/LICENSE\" e.g. quickapp-ide 寫的 PKGBUILD： package() { install -Dm 644 201809171830002525474.docx \"$pkgdir/usr/share/licenses/$pkgname/LICENSE.docx\" cd \"$pkgname-$pkgver\" # install -d opt/quickAppIDE # cp opt/quickAppIDE ${pkgdir} # make DESTDIR=\"$pkgdir/\" install cp -r ./ ${pkgdir}/ } ","date":"2020-01-31","objectID":"/archlinux_makepkg/:6:4","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"md5sums 當我們在 ~/work/PKGBUILD 寫完我們的 PKGBUILD 後，接下來就是更新校驗的值，這時我們又要回到上面看一下 PKGBUILD 有一個參數是 md5sums/sha1sums/sha256sums，這裡就是我們要填上他的時候，在 Konsole 進入 /work 目錄下輸入以下指令： makepkg -g \u003e\u003e PKGBUILD 接下來你就可以在你寫的 PKGBUILD 文件裡看到文件末以填上 md5sums 屬性的內容。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:7:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"構建軟體包 各位最艱辛的寫 PKGBUILD 已經結束了，接下來就是我們的打包時刻了。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:8:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"用 zstd 來取代 xz 算法 系統預設使用的壓縮演算法是 xz，速度比較慢，推薦使用 zstd 算法，雖然 xz 打包出來的檔案相對小一點，但是壓縮時間和解壓縮時間都比 zstd 長很多，官方目前也建議用 zstd 來發佈，如果只是自己電腦安裝的話可以選擇不壓縮直接安裝。 編輯 /etc/makepkg.conf，找到最下面的 PKGEXT 修改裡面的值。 不壓縮 PKGEXT='.pkg.tar' zstd 算法 PKGEXT='.pkg.tar.zst' ","date":"2020-01-31","objectID":"/archlinux_makepkg/:8:1","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"構建 第一次構建先直接執行 makepkg -s，如果報錯後修改 PKGBUILD，下一次再構建的時候傳入參數 --repackage 直接執行打包函數，這樣可以節省一些時間。 註：這裡蠻坑的，如果出一個錯造成構建失敗，就要重新來過，要將因構建過程產生的資料夾或文件全砍掉。 makepkg --repackage 構建完成後如果你是用 zstd 算法 你就可以在 /work 產生一個包名為$pkgname-$pkgver.pkg.tar.zst。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:8:2","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"測試 PKGBUILD 與上傳至 AUR 關於這部份我就支持一下我參考的作者的文章，接下來的教學部份請看他後續寫的篇章。我這篇算是補足他前面不完美的部份。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:8:3","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"Reference 将 DEB 软件包转换成 Arch Linux 软件包 - Linux 中國 Creating packages (简体中文) - ArchWiki PKGBUILD (简体中文) - ArchWiki Arch Linux 第一次打包就上手 - 書術方隅 makepkg (簡體中文) - ArchWiki ","date":"2020-01-31","objectID":"/archlinux_makepkg/:9:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["Linux"],"content":"前言 我在這篇會分享我是如何在 Arch 上配置 Java 的開發環境。再來我必須說的是，我這個適用於你的電腦的 Linux SSD (root) 空間不夠的情況，大部分的人是 Windows 與 Linux 雙系統，像我只能把 SSD 割 30GB 給我 Linux (這是因為我電腦上的 Windows 有被廠商更改過，限制了割出的量)，而虛擬硬碟卻可以割到 100GB 以上，我會教大家如何將 Java 環境裝到 /home。如果覺得自己 SSD 夠用，就直接從 AUR 上 yay 下來，直接略過此次教學 (ﾒ ﾟ皿ﾟ)ﾒ，畢竟會有人覺得我這樣的做法讓系統管理有點髒。不過關於環境變量的配置可以參考我這篇文章，不管是裝在 SSD 還是 HDD。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:1:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"JDK 版本選擇 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:2:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"JDK 1.xxx 和 JDK xxx.0 比如 jdk 1.8 和 jdk 8 參考自這網站的介紹。 Sun 公司看別人的語言更新都更新到 xxx 了，自己的 Java 版本還是 1 點幾，讓人感覺很落後，所以在 jdk 1.6 的時候對外發布稱之為 jdk 6.0 ，讓人感覺更先進點。在寫 Java 的人眼裡都是叫 1.6 的，基本沒人說 6.0.。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:2:1","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"推薦的 JDK 版本 參考自這篇文章。 我推薦的是 JDK 1.8 版本，也就是 Java 8，因為它足夠穩定，對一些套件的依賴與支持完整高，也是目前新手入門最好的 JDK 版本。至於 1.8 以前的版本都不推薦因為過於老舊，目前 JDK 1.8 以後的版本不怎麼穩定，但如果想要嘗試新的開源項目可以嘗試最版本。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:2:2","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"下載 JDK 1.8 至 Oracle Java 下載處下載你要的 JDK 包，JDK 1.8。 註：下載需要註冊 Oracle 帳號，這裡要感謝網上的有些善心人士提供共享帳號。 Oracle 帳號：2696671285@qq.com Oracle 密碼：Oracle123 帳號來源 像我是下載這個。 JDK 1.8jdk.png \" JDK 1.8 下載下來 *.tar.gz 後將其解壓，將資料夾放入 ~/.local/usr/lib/jvm/ 路徑裡，如果沒有路徑資料夾就自己創建。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:3:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"下載 Tomcat 8 Tomcat 這裡我目前也比較推薦 Tomcat 8，目前 Tomcat 最新版出到 9，但是我實際做項目的時候發現 Tomcat 9 對於代碼的規範要求很多，不按照 Tomcat 9 的規範走會有很多警告，也影響開發時的觀感。 下載 Tomcat 8 Tomcat 8tomcat.png \" Tomcat 8 解壓後將資料夾放入 ~/.local/opt/tomcat/。如果沒有路徑資料夾就自己創建。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:4:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"下載 Maven 3 Maven 3 Maven 3maven.png \" Maven 3 解壓後將資料夾放入 ~/.local/opt/maven/。如果沒有路徑資料夾就自己創建。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:5:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"編輯 Tomcat 假設你的 JDK 版本是 jdk1.8.0_241。Tomcat 是 apache-tomcat-8.5.47。Maven 是 apache-maven-3.6.2。如果你的版本跟我不一致，就自行修改版本號。 編輯 ~/.local/opt/tomcat/apache-tomcat-8.5.47/bin/startup.sh，於文件末添加 JDK、JRE 配置內容： #java8 export JAVA_HOME=~/.local/usr/lib/jvm/jdk1.8.0_241 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH #tomcat8 export TOMCAT_HOME=~/.local/opt/tomcat/apache-tomcat-8.5.47 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:6:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"編輯 .profile 在 ~/.profile 添加以下內容，編輯完後執行 source ~/.profile 重新加載環境變量，使配置生效。然後登出登入一次電腦。 #java8 export JAVA_HOME=~/.local/usr/lib/jvm/jdk1.8.0_241 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH #tomcat8 export CATALINA_HOME=~/.local/opt/tomcat export CLASSPATH=.:$JAVA_HOME/lib:$CATALINA_HOME/lib export PATH=$PATH:$CATALINA_HOME/bin export CLASSPATH=$CLASSPATH:%JAVA_HOME/lib/tools.jar export TOMCAT_HOME=~/.local/opt/tomcat/apache-tomcat-8.5.47 export CATALINA_HOME=$TOMCAT_HOME export PATH=$PATH:TOMCAT_HOME/bin #maven3 MAVEN_HOME=~/.local/opt/maven/apache-maven-3.6.2 export MAVEN_HOME export PATH=${PATH}:${MAVEN_HOME}/bin ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:7:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"測試是否配置成功 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:8:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"JDK 在 Konsole 輸入 java -version 就會顯示 Java 版本。 Java 版本java_version.png \" Java 版本 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:8:1","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"Tomcat 於 ~/.local/opt/tomcat/apache-tomcat-8.5.47 目錄下打開 Konsole，啟動 Tomcat。 ./startup.sh Tomcat 運行tomcat_startup.png \" Tomcat 運行 接著打開瀏覽器輸入 http://127.0.0.1:8080/或http://localhost:8080/ 會出現以下畫面，此時代表已經配置成功。 Tomcat 運行結果tomcat_test.png \" Tomcat 運行結果 接下來輸入 ./shutdown.sh 中止 Tomcat。 中止 Tomcattomcat_shutdown.png \" 中止 Tomcat ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:8:2","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"Maven 在 Konsole 輸入 mvn -v 就會顯示你的 Maven 版本。 Maven 版本maven_version.png \" Maven 版本 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:8:3","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"IntelliJ IDEA 透過國內阿里云鏡像加速建立 Maven 項目 關於如何使用 IntelliJ IDEA 建立 Tomcat 項目等我就不在這裡細說了，這些基礎的知識你們可以參考網上其它教學。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:9:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"添加國內鏡像 編輯 ~/.local/opt/maven/apache-maven-3.6.2/conf/ 目錄下的 settings.xml，於文末添加以下內容。 \u003cmirror\u003e \u003cid\u003enexus-aliyun\u003c/id\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003cname\u003eNexus aliyun\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public\u003c/url\u003e \u003c/mirror\u003e ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:9:1","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"IntelliJ IDEA 創建 Maven 項目 IntelliJ IDEA 創建 Maven 項目，如果是一般的 Maven 項目就在 Create fome archetype 選擇 maven-archetype-quickstart，如果是 Web 項目就選擇 maven-archetype-webapp。我這裡就演示建立 Web 項目。 建立項目 新建 Maven 項目IDEA_maven_create.png \" 新建 Maven 項目 項目目錄位置 設置 Project 位置IDEA_maven_location.png \" 設置 Project 位置 添加屬性 創建 Maven 項目時手動添加一個 archetypeCatalog 配置，其值設為 internal。 添加屬性IDEA_maven_property.png \" 添加屬性 Finish 後就建立好了一個 Maven Web 項目。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:9:2","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"添加 Tomcat Server 在右上角的 add configuration 添加 Tomcat Server。 添加 Tomcat Server 設置IDEA_tomcat_config.png \" 添加 Tomcat Server 設置 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:10:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"Reference ubuntu16.04安装及配置tomcat,IDEA集成tomcat及部署web项目，IDEA通过阿里云镜像加速maven项目创建 java 版本區別，java SE是什麼，下載JDK時各個名稱的含義 jdk版本的选择（推荐1.8）- 知乎 Oracle官网登录下载资源账号密码共享 - AlanLee 博客園 Tomcat ( 三 )：測試 Tomcat ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:11:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"前言 在 Linux 開發 Python 相關的項目，你是不是會碰到關於 Python 版本之類的問題？像是開發 Tensorflow 的時候碰到版本問題，原本 Python 3.7 可以支援 Tensorflow，但是忽然 Python 從 3.7 更新到 3.8.0，這時 Python 3.8 不支援 Tensorflow，你苦惱了，千辛萬苦的項目因為系統更新而導致版本不支援使項目暫停開發，這時 pyenv 將成為你的救星，如果你硬是不肯更新系統 Python 版本，你的系統將會得不到最新的體驗與安全並處於危險的不穩定狀態，系統更新真的很重要。 pyenv 是很棒的 Python 版本控制工具，讓你的電腦可以安裝多個 Python 版本。pyenv 是 Github 上的開源項目，關於使用須知該項目的 README.md 寫得很詳細。我這篇文章就分享一下我在 Arch Linux 的安裝方式。 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:1:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"安裝 從 Github 倉庫上直接 clone 下來。你也可以選擇直接在瀏覽器上下來。然後壓縮包解壓將文件內的文件放入 ~/.pyenv。 註：如果你在國內網使用 Github 網速過於緩慢，建議開 Proxy，然後給 Git 設置代理。 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:2:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"設置代理 # set http git config --global http.proxy 'socks5://127.0.0.1:1080' # set https git config --global https.proxy 'socks5://127.0.0.1:1080' # unset http git config --global --unset http.proxy # unset https git config --global --unset https.proxy npm config delete proxy ","date":"2020-01-27","objectID":"/linux_python_pyenv/:2:1","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"下載 git clone https://github.com/pyenv/pyenv.git ~/.pyenv # Basic GitHub Checkout ","date":"2020-01-27","objectID":"/linux_python_pyenv/:2:2","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"環境變量 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:3:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"PYENV_ROOT 將 PYENV_ROOT 添加至環境變量。在 Konsole 輸入以下指令： 註：在 Arch 發行版中，~/.bash_profile 就是 ~/.profile。如果你 Shell 使用的是 ZSH，為了在 ZSH 中也能使用，記得也要寫入 ~/.zshrc。之所以要求要兩個都寫入是因為避免如果你如果換了其它 Shell 需要再重新設一次。 # .profile echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e ~/.profile echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e ~/.profile # .zshrc echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e ~/.zshrc echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e ~/.zshrc ","date":"2020-01-27","objectID":"/linux_python_pyenv/:3:1","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"pyenv init 將 pyenv init 添加到您的 Shell 中以啟用填充和自動補全功能。 請確保將 eval\" $（pyenv init-）\" 放在 Shell 配置文件的末尾，因為它在初始化期間會操縱 PATH 。 輸入以下指令： # .profile echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init -)\"\\nfi' \u003e\u003e ~/.profile # .zshrc echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init -)\"\\nfi' \u003e\u003e ~/.zshrc ","date":"2020-01-27","objectID":"/linux_python_pyenv/:3:2","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"重啟 SHELL 先重新加載環境變量文件後，重啟 Shell。 source ~/.profile source ~/.zshrc 接下來你輸入 pyenv version，應該就會顯示你目前 pyenv 使用的 Python 版本，輸入 pyenv versions 能顯示你 pyenv 中安裝的所有 Python 版本。 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:4:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"安裝 Python 版本 我目前要使用 Python 3.7.6 的版本。 pyenv install 3.7.6 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:5:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"設置 Shell 默認全局 Python 版本 pyenv global 3.7.6 接下來重新登出登入電腦。使用 python --version 查看 Python 版本就會發現版本已經變成 3.7.6 了。 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:6:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"Reference pyenv / pyenv - Github Git 設置與取消代理 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:7:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["ArchLinux"],"content":"前言 Wallpapaer Engine 是非常優秀的動態桌布軟體，可惜的是這軟體不僅是需付費，也只支援 Windows，關於 KDE 動態桌布可能大家會有疑慮，Plasma KDE 究竟能不能實現動態桌布？答案是可以的，在這篇我將分享我完成動態桌布的過程。 當然，我也嘗試過使用 vlc 和 xwinwrap + mplayer，尤其是 xwinwrap 最折騰我，包括開機自啟，最後的效果都讓我不滿意。但是目前網上（包含 KDE 官網）所有關於 KDE 動態桌布的項目不是使用上不美觀或是沒效果（黑屏）。最後終於在一篇 Github 項目中看到黑屏的處理方法，無意間那些 KDE Video Wallpaper 插件都可以用了。 如果執意想使用 vlc 或是 xwinwrap + mplayer 的讀者可以參考某人的 Blog：设置 Linux 动态桌面的几种办法 - 簡書 ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:1:0","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"Plasma Video Wallpaper ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:2:0","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"WuSiYu / Plasma Video Wallpaper 這是 Github 上看到的項目，這也是因為我看到他在 B 站上的視頻才知道有這個項目。 完整項目使用過程他已經在他 Github 項目的 README.md 說得很清楚了。 先將項目下載解壓，進入項目目錄輸入以下指令： 如果沒有安裝 cmake、make 就裝一下，如果有權限問題就給權限。 sudo pacman -S cmake make # 安裝 cmake make cmake . make sudo make install 安裝完後重新登出登入重啟 Plasma。 特別注意：這個插件不能用來當鎖屏的動態桌布！我之前曾經試過利用這個將鎖屏設為動態壁紙，一開始還好好的，但是到後面慢慢出現程序問題，換回普通壁紙就好。 ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:2:1","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"halverneus / org.kde.video 這也是我一間發現的項目，號稱是鎖屏動態壁紙插件，但我為了執行內存空間上我還是沒用這個。但我也因為這個項目的 README.md 才發現黑屏原因。 ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:2:2","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"黑屏 面對黑屏怎麼辦？黑屏的原因是因為你有些插件沒有安裝。安裝 qt-gstreamer 和 gst-libav。 補充：KDE 是使用 Qt 實現的，所以系統軟體裡自帶 Qt，不能亂砍。 sudo pacman -S qt-gstreamer gst-libav 安裝完並重啟 Plasma 就可以了，我教我的幾位同學們安裝這兩個插件後動態桌布都可以實現了，不再是黑屏。 ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:3:0","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"桌面怖局 記的桌面布局要選擇桌面。如果選擇資料夾有可能顯示不出動態桌布。 設定動態桌布01.png \" 設定動態桌布 ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:4:0","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"重要補充 動態壁紙有時很吃電腦內存，如果內存小於 8GB 建議還是別使用動態桌布。 ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:5:0","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"Reference WuSiYu/Plasma Video Wallpaper 【原创】Linux KDE Plasma桌面 视频动态壁纸插件 设置 Linux 动态桌面的几种办法 halverneus / org.kde.video ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:6:0","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"前言 我想我在 Linux 上用最多也最重要的就是終端機 Konsole 了，我們默認的是 Bash，然而 bash 過於單調，也沒有自動補全，這時我們就需要開源項目 oh-my-zsh，在這篇教學我會寫一下，我配置 oh-my-zsh 的過程。 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:1:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"我的 Konsole 我的終端機02.png \" 我的終端機 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:2:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"Konsole 透明度設置 在標題欄點擊滑鼠右鍵。 設定透明度01.png \" 設定透明度 在外觀與修復中，可以調整透明度。我調成不透明度 80%。 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:3:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"安裝 zsh sudo pacman -S zsh ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:4:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"查看系統當前使用的 Shell echo $SHELL # 查看指令 /bin/bash # 輸出結果 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:5:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"看系統是否裝了 zsh cat /etc/shells # 輸入指令 # Pathnames of valid login shells. # See shells(5) for details. /bin/sh /bin/bash /usr/bin/git-shell /bin/zsh /usr/bin/zsh ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:6:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"切換 Shell 為 zsh 註：不需要加 sudo。 chsh -s /bin/zsh # 切換指令 # 輸出結果 Changing shell for root. Shell changed. 將所有終端機都關掉，或是登入登出一次，再次查看當前的 Shell 應該就是 zsh 了。 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:7:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"安裝 oh-my-zsh 這裡或許看 github 官網會比較好。三種安裝方式，通常第一種就可以了。 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:8:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"curl sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:8:1","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"wget sh -c \"$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:8:2","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"Manual inspection It’s a good idea to inspect the install script from projects you don’t yet know. You can do that by downloading the install script first, looking through it so everything looks normal, then running it: curl -Lo install.sh https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh sh install.sh ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:8:3","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"配置主題 我在這裡推薦的是 ys 主題。 編輯 ~/.zshrc。 vim ~/.zshrc 將 ZSH_THEME 改成 ys。 ZSH_THEME=\"ys\" ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:9:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"推薦插件 插件依然需要編輯 ~/.zshrc ，找到 plugins=，然後在裡面寫需要的插件名，有些插件可能還需要安裝。 注意：只要改了此文件，重啟終端后有效或使用 source ~/.zshrc 更新配置。 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"extract 用來解壓縮文件，用起來很爽，根本不需要去記憶各種解壓縮指令，一套 x filmname 直接幫你解壓好。 當然，如果你想要用 tar 命令，可以使用 tar - 加 tab 鍵，zsh 會列出參數的含義。 這插件預設安裝就有，不需要額外安裝。 plugins=(其他的插件 extract) ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:1","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"zsh-autosuggestion 自動補全。可記錄之前輸過的指令。 git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions plugins=(其他的插件 zsh-autosuggestion) ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:2","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"zsh-syntax-highlighting 終端字體高亮。 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting plugins=(其他的插件 zsh-syntax-highlighting) ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:3","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"git-open git-open 插件可以在你 Git 項目下打開遠程倉庫瀏覽項目。 git clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open plugins=(其他的插件 extract) 使用： git open [remote-name] [branch-name] # Open the page for this branch on the repo website git open --commit git open -c # Open the current commit in the repo website git open --issue git open -i # If this branch is named like issue/#123, this will open the corresponding # issue in the repo website git open --print git open -p # Only print the url at the terminal, but don't open it ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:4","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"bat bat 代替 cat。 cat 某個文件，可以在終端直接輸出文件內容，bat 相比 cat 增加了行號和顏色高亮。 P.S. 我好像不怎麼用這個。所以沒裝。 2020/07/29 更新：bat 實在是太好看了，大推。 sudo pacman -S bat ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:5","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"incr 可以說 incr.zsh 這插件是最強的自動補全插件，還能幫你搜索線上的倉庫是否有你所需要的軟體包。建議搭配 zsh-autosuggestion 一起使用，我將這兩個插件都裝了。 到這個網站下載 incr.zsh 文件，將此文件放置 ~/.oh-my-zsh/custom/plugins/incr 資料夾裡，如果沒有資料夾就自己新增。 在 ~/.zshrc 文末添加一行。 source ~/.oh-my-zsh/custom/plugins/incr/incr*.zsh ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:6","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"插件配置 vim ~/.zshrc source ~/.zshrc 以下是我的 ~/.zshrc 設定。 # If you come from bash you might have to change your $PATH.# export PATH=$HOME/bin:/usr/local/bin:$PATH# Path to your oh-my-zsh installation.export ZSH=\"/home/rem/.oh-my-zsh\"# npmexport PATH=$PATH:~/.npm-global/bin# Set name of the theme to load --- if set to \"random\", it will# load a random theme each time oh-my-zsh is loaded, in which case,# to know which specific one was loaded, run: echo $RANDOM_THEME# See https://github.com/robbyrussell/oh-my-zsh/wiki/ThemesZSH_THEME=\"ys\"# Set list of themes to pick from when loading at random# Setting this variable when ZSH_THEME=random will cause zsh to load# a theme from this variable instead of looking in ~/.oh-my-zsh/themes/# If set to an empty array, this variable will have no effect.# ZSH_THEME_RANDOM_CANDIDATES=( \"robbyrussell\" \"agnoster\" )# Uncomment the following line to use case-sensitive completion.# CASE_SENSITIVE=\"true\"# Uncomment the following line to use hyphen-insensitive completion.# Case-sensitive completion must be off. _ and - will be interchangeable.# HYPHEN_INSENSITIVE=\"true\"# Uncomment the following line to disable bi-weekly auto-update checks.# DISABLE_AUTO_UPDATE=\"true\"# Uncomment the following line to automatically update without prompting. DISABLE_UPDATE_PROMPT=\"true\"# Uncomment the following line to change how often to auto-update (in days).# export UPDATE_ZSH_DAYS=13# Uncomment the following line if pasting URLs and other text is messed up.# DISABLE_MAGIC_FUNCTIONS=true# Uncomment the following line to disable colors in ls.# DISABLE_LS_COLORS=\"true\"# Uncomment the following line to disable auto-setting terminal title.# DISABLE_AUTO_TITLE=\"true\"# Uncomment the following line to enable command auto-correction.# ENABLE_CORRECTION=\"true\"# Uncomment the following line to display red dots whilst waiting for completion.# COMPLETION_WAITING_DOTS=\"true\"# Uncomment the following line if you want to disable marking untracked files# under VCS as dirty. This makes repository status check for large repositories# much, much faster.# DISABLE_UNTRACKED_FILES_DIRTY=\"true\"# Uncomment the following line if you want to change the command execution time# stamp shown in the history command output.# You can set one of the optional three formats:# \"mm/dd/yyyy\"|\"dd.mm.yyyy\"|\"yyyy-mm-dd\"# or set a custom format using the strftime function format specifications,# see 'man strftime' for details.# HIST_STAMPS=\"mm/dd/yyyy\"# Would you like to use another custom folder than $ZSH/custom?# ZSH_CUSTOM=/path/to/new-custom-folder# Which plugins would you like to load?# Standard plugins can be found in ~/.oh-my-zsh/plugins/*# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.plugins=( git extract archlinux vscode z colored-man-pages zsh-syntax-highlighting zsh-autosuggestions git-open)source $ZSH/oh-my-zsh.shsource /etc/profile# User configuration# export MANPATH=\"/usr/local/man:$MANPATH\"# You may need to manually set your language environment# export LANG=en_US.UTF-8# Preferred editor for local and remote sessions# if [[ -n $SSH_CONNECTION ]]; then# export EDITOR='vim'# else# export EDITOR='mvim'# fi# Compilation flags# export ARCHFLAGS=\"-arch x86_64\"# Set personal aliases, overriding those provided by oh-my-zsh libs,# plugins, and themes. Aliases can be placed here, though oh-my-zsh# users are encouraged to define aliases within the ZSH_CUSTOM folder.# For a full list of active aliases, run `alias`.## Example aliases# alias zshconfig=\"mate ~/.zshrc\"# alias ohmyzsh=\"mate ~/.oh-my-zsh\"source ~/.oh-my-zsh/plugins/incr/incr*.zsh ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:11:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"Reference oh-my-zsh,让你的终端从未这么爽过 oh-my-zsh让终端好用到飞起~ ohmyzsh - github zsh+on-my-zsh配置教程指南（程序员必备）【已备份】 git-open - Github ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:12:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"前言 我們在 Part 2 中已將基本的圖形界面以及中文字體等配置好，接下來我會在這篇中推薦一些實用的軟體與界面風格。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:1:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"文本編輯器 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:2:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Kate 可作為記事本使用。 sudo pacman -S kate ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:2:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Typora 美化你的文本，編寫 Markdowm 語言，具有跨平台優點，Linux 上的 *.docx 拿到 Windows 上的 Office 容易走版，使用 Markdown 寫的文件不會有這問題。 sudo pacman -S typora ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:2:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Visual Studio Code 一個輕快的編輯器，讓你的開發效率迅速提升。 在 AUR 中 VScode 軟體包稱作 code。 sudo pacman -S code ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:2:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"辦公軟體 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:3:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"WPS Office 作為在 Linux 上的最佳 MS 替代品，因為 MS 的 Office 不開源，所以無法在 Linux 使用 MS Office。WPS 在 Linux 不會有廣告，所以放心。 你可以使用 pacman 安裝 WPS Office，但僅限 64-bit Arch 使用者。 yay -S wps-office ttf-wps-fonts # WPS 與 WPS 需要的符號字體 WPS 改變界面語言的方法是，隨便開啟 WPS 其中一個軟體，像是 Writer，新增一個空白文件，後在右上角的小框框選界面語言。 WPS 變更界面語言01.png \" WPS 變更界面語言 選擇簡體中文，似乎沒有正體中文的選項 :( WPS 變更界面語言選項02.png \" WPS 變更界面語言選項 接著重啟 WPS 就會出現簡體中文的界面，也能正常輸入中文，每次開機打開 WPS 都會出現個錯誤框，按關閉就好，不影響使用。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:3:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"LibreOffice 同時支持 Windows、Macintosh 和 Linux 系統。 如果不在乎一定要 MS 的風格，我強烈建議使用 LibreOffice，功能齊全，軟體多，提供了六種文檔編輯與數據應用的應用。 sudo pacman -S libreoffice-fresh # 嘗新版 sudo pacman -S libreoffice-still # 穩定版 LibreOffice 中文界面的語言包 簡體中文使用者 sudo pacman -S libreoffice-fresh-zh-cn # 嘗新版 sudo pacman -S libreoffice-still-zh-cn # 穩定版 繁體中文使用者 sudo pacman -S libreoffice-fresh-zh-tw # 嘗新版 sudo pacman -S libreoffice-still-zh-tw # 穩定版 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:3:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"文件管理器 我這裡建議是安裝 Dolphin，重要的是好看。 sudo pacman -S dolphin 然後因為文件管理器預設是滑鼠左鍵點一下就進入資料夾或執行動作，所以需要到設定 \u003e 工作空間 \u003e 工作空間行為 \u003e 一般行為中將點擊行為改成按兩下開啟檔案或資料夾，接著應用變更。 設置滑鼠點擊事件03.png \" 設置滑鼠點擊事件 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:4:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"媒體播放器 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:5:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"MPV MPV 算是 Linux 下簡潔的音訊播放器。 sudo pacman -S mpv ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:5:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"網易雲音樂 網易雲還是不錯的音樂播放器。 sudo pacman -S netease-cloud-music 網易雲04.png \" 網易雲 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:5:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"圖形 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"截圖工具 我使用 flameshot 習慣了，而且蠻好用。 sudo pacman -S flameshot flameshot gui # 截圖 flameshot gui -d 3000 # 延時 3 秒截圖 Spectacle 也是不錯的截圖工具，但是功能上沒 flameshot 那麼完備。 sudo pacman -S spectacle ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"圖片檢視器 安裝 digikam 後就自動幫你安裝了 sudo pacman -S showfoto ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"圖片編輯器 遺憾的是目前做好的圖片編輯自依然是 PhotoShop，而且 PS 不開源也不兼容 Linux，所以如果真的想要使用 PS 高級圖片處理就切到 Windows 去吧，Linux 都是開源軟體，沒有軟體能比得上 PS。 sudo pacman -S digikam ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Gif 圖片 註：不推薦用這個錄屏。推薦使用下面的 kazam Peek 可以錄製螢幕並轉成 Gif。 sudo pacman -S peek ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"錄屏工具 這個工具使用很方便，推薦。 yay -S kazam ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:5","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"繪圖 krita 堪稱 Linux 上的 PS，開源。 yay -S krita ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:6","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"百度網盤 沒錯，你沒看錯，在 Linux 也可以使用百度雲下載東西。 sudo pacman -S baidunetdisk-bin ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:7:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"通訊軟體 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:8:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Telegram 強推 Telegram。 Telegram 需要翻牆。 sudo pacman -S telegram-desktop ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:8:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Discord 自從 zoom 取消免費之後，加上騰訊相關產品無法在 Linux 上運行，然而我們需要通訊會議，這個是最適合的，包括語音和屏幕分享。實在是太好用了。 Discord 網頁版也做得很好，騰訊會議就沒有網頁版。 sudo pacman -S discord # 穩定版 sudo pacman -S discord-ptb # 測試版 sudo pacman -S discord-canary # 最新版，我都直接裝最新版 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:8:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"TIM 你更沒聽錯，在 Linux 上真的可以使用 TIM，但是 WeChat 無法使用，只是我平常也不用 WeChat，WeChat 很垃圾。騰訊的通訊軟體都極度不安全。 sudo pacman -S deepin.com.qq.office Arch 發行版 KDE Plasma 桌面會無法打開 TIM，解決方法如下： 先下載安裝 gnome-settings-daemon 套件 sudo pacman -S gnome-settings-daemon 進入設置 \u003e 工作空間 \u003e啟動與關閉 \u003e 自動啟動中將 /usr/lib/gsd-xsettings設為自動啟動。 自動啟動05.png \" 自動啟動 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:8:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"IDE ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:9:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Intelli IDEA sudo pacman -S intellij-idea-community-edition # 社區免費版 sudo pacman -S intellij-idea-ultimate-edition # 付費專業版 安裝 Java 環境。 Arch Linux官方只支持 OpenJDK 實現。 安裝之後，Java 環境需要被 shell（$PATH 變量）識別。可以通過命令行用 source 處理 /etc/profile 或者重新登出登入桌面環境。 sudo pacman -S java-runtime-common # JRE sudo pacman -S java-environment-common # JDK 2020/07/29 更新：安裝 intellij-idea-ultimate-edition，因為一直無法啟動 IDEA，網上搜一下，發現還要裝另一個套件 原文：AUR intellij-idea-ultimate-edition 下面的討論區 sudo pacman -S intellij-idea-ultimate-edition-jre ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:9:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Pycharm 貌似需要使用 yay 直接從 AUR 下載安裝，pacman 庫沒有。其實我覺得 Python 直接用 VScode 寫就好了，但有些人不習慣，所以在這裡列出 Pycharm。 yay -S pycharm-community-edition # 社區版 yay -S pycharm-professional # 專業版 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:9:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"解壓 這裡還是要提醒，*.zip 才是壓縮檔案，不建議使用 *.rar，但是如果有人傳給你 *.rar，你也只能將他解壓縮，這裡下載 unrar。 sudo pacman -S zip unrar ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:10:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"瀏覽器 這裡我主要推薦是使用 Firefox，在 Linux 上，Firefox 比 Chromium 更省內存，之前有段期間我一直是使用 Chromium，每次開機沒多久就整個電腦卡死，自從換成了 Firefox 就順暢很多。當然如果你有 Google 帳號的一些使用者存儲或是電腦性能夠好，裝個 Chromium 也沒問題。 重要的是 Firefox 的應用商店沒有被牆。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:11:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Chromium 就是 Chrome，然而使用上還是有很多問題。 sudo pacman -S chromium 通常翻牆需要 SwitchyOmega 這個工具，需要從 Chrome 應用商店下載，但是因為 Chrome 應用商店已經被牆了，所以必須用另一種方式開啟 Chromium。 Konsole 輸入指令，使用 Proxy 開啟 Chromium 瀏覽器，進行登入 Google 帳戶和安裝 SwitchyOmega。 先開啟 Proxy，關於 Proxy 請看下一個內容。 chromium --proxy-server=\"socks5://127.0.0.1:1080\" ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:11:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Firefox 強推。記得從應用商店安裝 SwitchyOmega。 sudo pacman -S firefox-nightly # 最新版 sudo pacman -S firefox # 穩定版 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:11:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Proxy 在牆國，為了進行科學上網，建議各位還是租個翻牆比較好。這裡我就不貼出使用細節，畢竟涉及個人隱私。當然如果你喜歡 Baidu 也不是不行，但你要知道你使用 Baidu 是做不出任何科研成果的，Github 的訪問如果不開 Proxy 就是限速卡死。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:12:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Shadowsocks 以下是 GUI 版的客戶端。缺點是無法使用訂閱。 sudo pacman -S shadowsocks-qt5 Shadowsocks06.png \" Shadowsocks ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:12:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"ShadowsocksR 簡稱 SSR，由於很久沒更新了，容易被牆識別，雖然使用方便，但不建議使用。以下是 GUI 版的客戶端。 sudo pacman -S electron-ssr ShadowsocksR07.png \" ShadowsocksR ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:12:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"V2ray 算是蠻新的代理器，速度穩定快速，但是很燒流量，你翻牆的流量會被乘 2.5 倍。 sudo pacman -S v2ray # 下載安裝 v2ray v2ray -version # 查看版本 v2ray --config=config.json # 啟動 v2ray # 如果想開機自啟可以這樣做 systemctl enable v2ray # 開機自啟 systemctl start v2ray ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:12:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Clash 強推，可以自動偵測是否為大陸網域進行是否使用代理，但貌似只能使用訂閱。沒有 GUI。 下載 clash。 sudo pacman -S clash 進入 ~/.config/clash 下載自己的 config.yml。如果 ./config 裡面 clash 沒有就自己新增。 這裡需要注意的是如果你的 Konsole 是 ZSH，你使用 Wget 需要將 URL 用雙引號包住。Bash 的話應該是沒關係。 cd ~/.config/clash sudo pacman -S wget wget -O config.yml \"xxxxxxxxxxxxxxx\" 接著修改 config.yml 的 socks-port 代理端口為 1080。 接下來需要新的的文件是 Country.mmdb，這份文件已經被牆國牆了，所以需要手動到網上下載。我姑且將該份文件上傳到百度網盤，密碼是 vsor，希望別被砍掉。如果被砍掉了，我又在 Github 上傳該份文件。 將 Country.mmdb 放入 ~/.config/clash。如果需要看到隱藏的資料夾可以在檔案管理器檢視的地方選擇顯示隱藏檔案或資料夾。。 再來就是執行 clash 了。 clash # konsole 輸入 clash 可以進入 Clash Dashboard 進行切換節點與測延遲等操作。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:12:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"neofetch 可以快速察看電腦狀況。好看。 sudo pacman -S neofetch neofetch # 執行 neofetch neofetch13.png \" neofetch ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:13:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"界面美化 關於這部份我就寫自己推薦的部份，畢竟每個人的審美不同，沒必要照我的來。也可以自行探索，細節也不詳細講。可以在設置中玩玩。KDE Plasma 的使用者可以到線上的 KDE 商店看看，Gnome 則可到 Gnome 商店。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Latte Dock 像 Mac 風的任務管理器。強推，很好看。 sudo pacman -S latte-dock 下載完在應用管理器開啟就能跑出來了。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Theme 我偏向 Mac 風，Mac 風真的好看。 將 McMojave KDE Theme 從 Github 下載下來，解壓壓縮包後進入資料夾，執行以下指令： ./install.sh preview McMojave Dark ThemeMcMojave_dark.png \" McMojave Dark Theme ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Icon 下面是我比較喜歡的 Icon 風格，你都可以裝來玩玩看。 yay -S numix-circle-icon-theme-git yay -S papirus-icon-theme-git # 推薦，太好看了 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"SDDM 2020 / 01 / 02 補充 我在這裡推薦使用 Suger Candy for SDDM，幸好也有人放上了 AUR。 官方文檔也在設置檔案的參數說明得很清楚，我就不再這多贅述了。在 /usr/share/sddm/themes/Sugar-Candy/ 的 theme.conf 進行修改。 sudo pacman -S sddm-theme-sugar-candy-git Sugar Candy SDDMPartialBlur.png \" Sugar Candy SDDM ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"GRUB THEME 沒錯！GRUB 也可以改成自己想要的，將 Flat Design themes for Grub2 zip 包從 Github 下載下來，解壓後進入資料夾輸入官網說的安裝教學。細節修改可以進入 /usr/share/grub/themes/ 裡面自行修改。 我裝的主題是 Tela grub theme，有修改字體大小和字型，編輯 /usr/share/grub/themes/Tela/theme.txt： item_font = \"Noto Sans Regular 24\" Tela Grub Themegrub-theme-tela.jpg \" Tela Grub Theme ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:5","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"窗口特效 在設置 \u003e 工作空間 \u003e 工作空間行為 \u003e 桌面效果中可以選擇特效。 我建議將以下選項勾起來，蠻好玩的。 桌面特效09.png \" 桌面特效 桌面特效 - 最小化視窗10.png \" 桌面特效 - 最小化視窗 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:6","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"窗口的 MAC 按鈕 將視窗搞的像 MAC 按鈕位置。 先隨意在一個視窗標題欄點擊滑鼠右鍵，更多工作 \u003e 設定視窗管理員。 視窗管理員11.png \" 視窗管理員 調整窗口的標題列按鈕。 設定視窗12.png \" 設定視窗 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:7","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Reference WPS Office (简体中文) - ArchWiki LibreOffice (简体中文) - ArchWiki Localization/Simplified Chinese (简体中文) - ArchWiki netease-cloud-music - AUR 2019年wine QQ最完美解决方案（多Linux发行版通过测试并稳定运行） Java (简体中文) - ArchWiki Linux 下好用的四款 ss/ssr 客戶端 AUR intellij-idea-ultimate-edition 下面的討論區 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:15:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"前言 我們已經在 Part 1 將基本的系統裝好了，接下來是安裝完的後續步驟。 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:1:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"確認連網 我們在上次的安裝教學 Part 1 已經在尾部補充將 networkmanager 裝上了，所以你不需要像上次教學那麼繁瑣，基本插網線就能連到。 註：注意使用 systemctl 啟用 networkmanager 服務時要注意大小寫，開頭要大寫。 systemctl enable NetworkManager # 設定開機自啟 systemctl strat NetworkManager # 啟用 Netmanager ping baidu.com # 確認連網 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:2:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"添加使用者 在上一期教學我們已經設定了超級使用者，即 Root，但是使用 Root 進行日常操作是不安全的，應創建用戶組進行日常操作，僅在系統管理時使用 Root。 另一方面，我們無法使用超級使用者進入圖形界面。 註：將以下的所有 user 改成自己的使用者名稱。 useradd -G wheel user # 新增使用者 passwd user # 設定使用者密碼 chfn user # 添加使用者信息，可暫時不填 mkdir -m 700 /home/user # 創建主目錄 chown user:user /home/user # 修改使用者與使用者群組 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:3:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"sudo 安裝 為了安全，我們可以使用 sudo 進行 root 權限操作，編輯 /etc/sudoers。 註：這裡不能使用 vim 編輯，會顯示權限不足，是只讀狀態，所以要改用 nano。 pacman -S sudo # 安裝 sudo nano /etc/sudoers # 編輯 /etc/sudoers 接著將上一步驟的使用者添加到 sudo。添加 user ALL = (ALL) ALL 在 root 下面。 註：將 user 改成上一步驟你新增的使用者名稱。 root ALL = (ALL) ALLuser ALL = (ALL) ALL # 新增使用者 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:4:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"添加 ArchLinuxcn 源 註：2020/07/29 關於 GPG 金鑰遇到的問題解決方法，我已經補充到此文末的重要補充 Archlinuxcn 庫有很多平常實用的工具，但是官方倉庫沒有的東西。 編輯 /etc/pacman.conf nano /etc/pacman.conf 在文件末添加清華大學 CN 源，並順便將 multilib 註解去除，因為後續裝一些軟體需要到這個庫。 # 去掉 multilib 註解[multilib]Include = /etc/pacman.d/mirrorlist# 添加 CN 源[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch archlinuxcn-keyring 套件導入 GPG 金鑰。 pacman -Sy archlinuxcn-keyring ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:5:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"安裝圖形界面 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:6:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"Xorg 使用 xorg 啟動桌面環境。 pacman -S xorg ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:6:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"圖形界面選擇 我比較推薦 KDE Plasma 或是 Gnome，兩者是最大主流，但因為 KDE 比 Gnome 乾淨，所以我選擇了 KDE Plasma。 KDE Plasma KDE Plasma01.png \" KDE Plasma 有三種選擇的安裝包，我建議是 安裝第二種完整版，因為完整版就像 Google 一整套全家統，一個套件更新，其他依賴套件一起更新。 基本包 pacman -S plasma 完整包 pacman -S plasma-meta # 推薦 最簡安裝包（僅有桌面軟體） pacman -S plasma-desktop Gnome Gnome02.png \" Gnome Gnome 桌面只要安裝 gnome 包即可，還有一個 gnome-extra 包可以提供額外的常用軟體和幾個遊戲，你可以安裝時選擇你要的軟體，沒必要全選，當然也可以不装這个包。 私人強烈建議不安裝 gnome-extra 這個包，太多垃圾了，我後面刪得很累 註：在輸入 pacman 下載安裝指令時套件之間的空格不影響其指令執行。 pacman -S gnome # 推薦 pacman -S gnome gnome-extra # 不推薦 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:6:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"啟動器 安裝啟動器後先別急進入圖形界面，如果你是雙顯卡會有顯卡衝突。 KDE Plasma 使用 SDDM 登入啟動器 pacman -S sddm Gnome 使用 GDM 登入啟動器 pacman -S gdm ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:6:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"顯卡衝突 相信如果你的筆電是雙顯卡，那很有可能遇到雙顯卡衝突，像我的是 Intel 和 nvidia 衝突，一般我會建議使用 Intel 內顯去驅動圖形界面。當然因為我的筆記型電腦是聯想 Y7000，所以對於顯卡的處理很麻煩。 一般處理方法 安裝 optimus-manager，幫你自動產生 xorg.conf。 pacman -S optimus-manager # 安裝 optimus-manager systemctl enable --now optimus-manager # 二選一 optimus-manager --switch intel # 切換到內顯 optimus-manager --switch nvidia # 切 N 卡 如果你需要重新選擇圖形界面的驅動方式，也就是選擇以哪個顯卡驅動，要刪除 /etc/X11/xorg.conf，再重新設定。 rm /etc/X11/xorg.conf # 刪除 /etc/X11/xorg.conf systemctl enable --now optimus-manager # 二選一 optimus-manager --switch intel # 切換到內顯 optimus-manager --switch nvidia # 切 N 卡 重啟電腦後使用啟動器進入圖形界面如果沒有問題就可以啟用自動啟動圖形界面。 KDE Plasma systemctl start sddm # 啟用圖形界面 systemctl enable sddm # 開機自啟 Gnome systemctl start gdm # 啟用圖形界面 systemctl enable gdm # 開機自啟 聯想 Y7000 的方法 因為 optimus-manager 無法解決聯想 Y7000 的顯卡衝突，關於這裡的解決方法我是詢問 Telegram #archlinux-cn 群中的 @HiyoriCao 大佬才得以解決。我因為不能使用獨顯進入圖形界面，所以就一直是用一個模式（核顯）。 首先 yay 大佬的包 – arch-prime-git 註：yay 可以直接從 AUR 倉庫上下載用戶上傳的最新軟件包。 註：Arch 使用者軟體倉庫 (AUR) 是由社群推動的使用者軟體庫。它包含了軟體包描述單 (PKGBUILD)，可以用 makepkg 從原始碼編譯軟體包，並透過 Pacman 安裝。 透過 AUR 可以在社群間分享、組織新進軟體包，熱門的軟體包有機會被收錄進 community[broken link: invalid section] 軟體庫。這份文件將解釋如何存取、使用 AUR。 pacman -S yay # 下載安裝 yay pacman -S base-devel # 下載安裝 base-devel 編譯工具包 yay -S arch-prime-git # 下載 arch-prime-git 如果有 Nvidia 卡，要先安裝 nvidia 套件，然後重起電腦，讓 arch-prime-git 能偵測到顯卡（Nvidia）。 pacman -S nvidia # 安裝 N 卡套件 先初始化 arch-prime-git。 註：這個指令貌似要在一般使用者中執行，不能是 Root 使用者（超級使用者），如果在 Root 使用者下無法執行 init，就輸入 exit 指令登出，重新以一般使用者登入。 prime-select init 這軟件包提供三種模式： 只用核顯 prime-select set intel 只用獨顯 prime-select set nvidia 動態切換 註：在設置環境變量的時候不能添加到 ./profile，因為這樣會設成全局變量，失去了動態切換的意義，在 Linux 上很少程序需要用到獨顯，除非是遊戲或是 Tenserflow 使用獨顯訓練。 prime-select set prime # 跑在核顯上 glxinfo | grep vendor # 跑在獨顯上 export NV_PRIME_RENDER_OFFLOAD=1 # 設置環境變量 GLX_VENDOR_LIBRARY_NAME=nvidia glxinfo | grep vendor 接著試著重啟電腦進入圖形界面，如果沒問題就啟用自啟圖形界面。 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:6:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"中文字體 進入 Plasma，預設會是英文，我推薦使用 Google 的開源字體 Noto Sans CJK，渲染出來的字體很好看。 pacman -S noto-fonts-cjk 進入 Plasma 後可以在設置中調整字體了，登出再登入就可以看到中文字體。 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:7:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"中文輸入法 我這裡選擇 Fcitx。這裡我參考了 @cheergo （Chun Yu）寫的文章內容。 註：Fcitx (Flexible Input Method Framework) ── 即小企鵝輸入法，它是一個以 GPL 方式發布的輸入法平台，可以通過安裝引擎支持多種輸入法，支持簡入繁出，是在 Linux 操作系統中常用的中文輸入法。它的優點是，短小精悍、跟程序的兼容性比較好。 註：Linux KDE 上切換輸入法的快捷建是 Ctrl + Space。 pacman -S fcitx fcitx-im 安裝新酷音輸入法。 pacman -S fcitx-chewing 輸入法設定介面。 pacman -S kcm-fcitx # KDE pacman -S fcitx-configtool # GNOME 編輯 /etc/profile，開頭加入三行。 vim /etc/profile export XMODIFIERS=\"@im=fcitx\"export GTK_IM_MODULE=\"fcitx\"export QT_IM_MODULE=\"fcitx\" ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:8:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"NTFS-3G 為了能掛載病讀取外部磁碟（e.g. HDD、SSD），需要安裝 ntfs-3g。 如果你使用的文件系統是 Btrfs 或是 XFS 就不需要下載這東西。 pacman -S ntfs-3g ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:9:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"Konsole 進入圖形界面後需要安裝 Konsole 以便輸入指令。 pacman -S konsole ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:10:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"重要補充 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:11:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"聯想 Y7000 的連網問題 聯想筆電通常在連無線網路上有一個坑 - Networkmanager 無法啟用無線網卡，算是…聯想筆電的特色，這裡我感謝 Telegram #archlinux-cn 群中的 @Asterism 大佬幫助我解決問題。 許多筆記本電腦都有一個硬體按鈕（或開關）來關閉無線網卡，但是，網卡也可能被內核阻止。 可以由 Rfkill 處理。通常來說你需要禁用 ideapod_laptop。 先輸入 rfkill list 查看關於筆電的硬件開關。 關於 Rfkill 硬件狀態03.png \" 硬件狀態 這張圖片是我已經處理過的狀態，關於 Wireless LAN 的軟體與硬體禁止皆為 NO，但如果是還沒處理之前我的 Soft blocked（軟卡禁止）為 no、Hard blocked（硬卡禁止）為 yes。 註：modprobe 是內核模塊，想了解更多可以參考 Kernel module (简体中文) - ArchWiki sudo modprobe -r ideapad_laptop # 禁用 ideapod_laptop sudo tee /etc/modprobe.d/ideapad.conf \u003c\u003c\u003c \"blacklist ideapad_laptop\" # 永久生效 接著再次輸入 rfkill list 查看狀態，如果發現 Wireless LAN 的 Soft blocked 和 Hard blocked 都是 no就行了，無線網路也能連結了。 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:11:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"pacman 中 archlinux-cn 無法更新下載 如果你有在更新或下載時，顯示 GPG 失效或錯誤等訊息，可以嘗試用以下方法解決。我也都是靠這方法解決大部份問題。做完以下步驟後用 pacman 同步一下資料庫，然後再試著下載看看。 rm -rf /etc/pacman.d/gnupg pacman-key --init pacman-key --populate archlinux pacman-key --populate archlinuxcn ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:11:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"Reference General recommendations (简体中文) - ArchWiki Users and groups (简体中文) - ArchWiki Arch Linux下载与安装配置 - 天祺圍棋 NVIDIA Optimus (简体中文) - ArchWiki 在Arch Linux上使用aurman、yay、pakku、aurutils来替代Yaourt - ywnz Arch User Repository (正體中文) - ArchWiki Archlinux nvidia-prime like package arch-prime-git - AUR Fcitx (简体中文) - ArchWiki NTFS-3G (简体中文) - ArchWiki gnome_vs_kde Redirect to:Network configuration/Wireless#Rfkill caveat - ArchWiki Kernel module (简体中文) - ArchWiki ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:12:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["Moment"],"content":"前言 近期，全球上映了一部電影 – 《小丑》（英語：Joker，香港譯《JOKER小丑》，中國大陸譯《小丑》）是一部於 2019 年上映的美國心理驚悚片，改編自DC漫畫旗下的同名角色，這部電影的預告片極為令人驚嘆，深層的黑暗、社會的底層、現實的矛盾……等都驅使著我期待著這部電影上映，可惜的是我現在於大陸唸書，這部電影大陸不會上映，畢竟這是部充滿反社會負面情緒的電影 (◞‸◟)，超想回台灣看小丑。 這部電影也因為作品的人物描繪、情感細緻等因素，獲得了金預告獎 - 最佳前導預告提名、多倫多國際電影節 - 演員成就獎、威尼斯電影節 - 金獅獎、金紙夾獎與原聲音樂星獎。 ","date":"2019-10-13","objectID":"/joker_movie_moment/:1:0","tags":["小丑","Joker","影片賞析"],"title":"影片賞析 -- 小丑（Joker）","uri":"/joker_movie_moment/"},{"categories":["Moment"],"content":"心靈感觸 首先我就先說一下開場給我的感覺就是一種懸疑的電影，讓我看不透也摸不清，男主角換上小丑裝時就像帶上了神秘的面具，好比每個人出面對不同的人時會有不同的態度與舉止看不透真正的他，在電影起頭，男主角在街頭身著小丑服手拿廣告牌，中途被街頭的混混狠狠捉弄後畫面切到了精神病院，男主角在心理醫師面前談論他的幻想，這裡就引起了我的注意，女醫師問男主角亞瑟：「你知道你為什麼你會被關在這裡嗎？」接著亞瑟出了醫院坐公車去領藥，(ﾟдﾟ≡ﾟдﾟ) 你不是被關在精神病院嗎？但我沒有在意地繼續看下去，這裡是電影裡的第一個玄疑點，這時我對亞瑟的印象還是個心理跟正常人差不多，但很不幸遇到了一些倒霉事。 實際上，在電影的前幾十分鐘，我都認為亞瑟是個老實人，心理上稍微不正常而已，遇到了老闆不講理的指責、槍枝曝光後同事的背叛、被老闆開除而失去最愛的工作、地鐵上的三個精英青年殺人事件，這些人生失意都刻印在觀眾眼中，亞瑟被社會無情地拋棄，這時我又想起亞瑟開頭日記上寫的一句話：「我希望我的死比我的生命有價值。」這確實是個充滿抑鬱壓抑的文章。 這整部電影都讓我感到驚悚，尤其是最後亞瑟拿出手槍殺了節目主持人，亞瑟也給我看到了現實世界中真實的一面，或許有被誇大的成份，但毫無疑問地，這部電影體現了亞瑟可悲的人生。 ","date":"2019-10-13","objectID":"/joker_movie_moment/:2:0","tags":["小丑","Joker","影片賞析"],"title":"影片賞析 -- 小丑（Joker）","uri":"/joker_movie_moment/"},{"categories":["Moment"],"content":"Reference 【小丑】首支官方預告，10月3日(週四) 上映 - Youtube 小丑 (電影) - 維基百科 DC《小丑》万字终极解析，一个精神病患从受害者到恶魔的自白 - Youtube 《小丑》影评：DC极度现实之作 - BiliBili ","date":"2019-10-13","objectID":"/joker_movie_moment/:3:0","tags":["小丑","Joker","影片賞析"],"title":"影片賞析 -- 小丑（Joker）","uri":"/joker_movie_moment/"},{"categories":["C/C++"],"content":"前言 最近我朋友問了我一個關於一個小數轉進制的題目，雖然我當時很忙，但最後我還是抽出了時間幫忙解決，解題的一開始我以為題目挺簡單的，但在解題過程發現還蠻多小技巧要使用，我會在這篇文章分享我的解題過程。 ","date":"2019-10-11","objectID":"/c-_solving_decimal_programming/:1:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/c-_solving_decimal_programming/"},{"categories":["C/C++"],"content":"題目 我先給各位看一下題目。 Objective Programming using basic data types and control structures. Specification Write a program which converts a base-S floating point number with value in the range [0,1) to its equivalent base-D representation, where S, D =2, … , 10. You program should be able to convert an input number with at least 8 significant digits而且. Hint: Use input/output manipulators std::setw, std::setfill, and std::setprecision to format the output. Sample run Base conversion for numbers [0,1) with at least 8 significant digits. Convert a number from base-S to base-D (2\u003c=S\u003c=10, 2\u003c=D\u003c=10): Input S: 4 Input D: 9 Input a number [0,1)in base-4: 0.12341234 Error: 0.12341234 is an invalid base-4 number Input a valid base-4 number: 0.12301230 0.12301230(4) is equivalent to 0.42352295(10) \u0026 0.37266541(9) Process another Conversion or Quit? (C/Q) C Convert a number from base-S to base-D (2\u003c=S\u003c=10, 2\u003c=D\u003c=10): Input S: 8 Input D: 5 Input a number in base-8: 0.66666666 0.66666666(8) is equivalent to 0.85714281(10) \u0026 0.41203241(5) Process another Conversion or Quit? (C/Q) Q Note: Ÿ Download the grade sheet as the cover page of your homework report. Ÿ You may check the base converter for the assessment of your results. ","date":"2019-10-11","objectID":"/c-_solving_decimal_programming/:2:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/c-_solving_decimal_programming/"},{"categories":["C/C++"],"content":"題目理解 這題目要我們先輸入我們想要轉換的進制，從 base-S 進制轉成 base-D 進制，接著要輸入一個至少小數點後有 8 位的小數，首先判斷該小數是否是否符合 base-S 的進制，如果不符合就重輸入，符合就轉進制，最後格式化分別輸出 10 進制與 base-D 進制的小數。 ","date":"2019-10-11","objectID":"/c-_solving_decimal_programming/:3:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/c-_solving_decimal_programming/"},{"categories":["C/C++"],"content":"程序設計思路 在決定小數的類型時，我們需要知道： float 類型的有效數字為 6 ~ 7 位 double 有效數字 15 ~ 16 位 long double 有效數字 18 ~ 19 位 根據題目要求至少輸入小數點後有 8 位有效數字，我們應該選擇 double 類型為我們的小數類型。 在全程使用 double 類型的變數存取小數時，會遇到數字精確度的問題，也就是在取小數位數時或是在轉換時數字的累加上，極有可能碰到數字尾部（有效數字外）出現了不知所然的位數，導致精確度不準確，也順帶影響運算結果。 為了避免這種情況，我們需要使用 String 類型來存取我們輸入的小數，以獲取我們輸入時的小數位數有多少，再利用位數使用循環將字符串轉成 double 類型，這一步我們主要就是小數位數，後面關於進制檢查與轉換都要用到小數位數。 在依序獲取小數每位數字時，可以先乘 10，再使用 (int) 強制轉換類型取得整數部份，將乘 10 的小數減去整數部份，持續循環。 題意不會要我們轉換 10 進制以上的小數（2 \u003c= S \u003c= 10, 2 \u003c= D \u003c= 10），這代表我們不需要擔心遇到英文字母，但遇到了其實也不麻煩，只要在轉換的地方添加字母條件去- 判斷是否為字母。 我們需要優先將小數轉成 10 進制，再轉成其他進制，這樣會有效讓我們去設計算法，如果是設計一個函式通用所有的轉制會很吃力。 從非 10 進制轉換到 10 進制的演算法，我們使用指數加權法： 註：來源參考 - 進制轉換 (二進制、八進制、十進制、十六進制) - NotFalse 技術客 指數加權法2.png \" 指數加權法 e.g. 指數加權法範例3.png \" 指數加權法範例 代碼實現 int n = -1; // the power of n double base10 = 0; // copy convert1 // Continuously taking decimal places // convert to base-10 for(int i = 0; i \u003c significant; i++) { number *= 10; *convert1 += (int)number * pow(S, n); // e.g. 1.1 (base-2) -\u003e 1*2^0 + 1*2^(-1) = 1.5 (base-10) number -= (int)number; n -= 1; } 從 10 進制轉成非 10 進制的演算法，我們使用餘數乘積法： 註：來源參考 - 十进制小数转二进制小数方法 餘數乘積法4.png \" 餘數乘積法 e.g. 餘數乘積法範例5.png \" 餘數乘積法範例 代碼實現 base10 = *convert1; // copy n = -1; // init // Continuously taking decimal places // convert base-10 to base-D /* Because the precision of double is 16 , so multiply it by 17 and execute at least 17 times, otherwise it will enter an infinite loop. */ for(int i = 0; i \u003c 17; i++) { base10 *= D; *convert2 += (int)base10 * pow(10, n); base10 -= (int)base10; n -= 1; if(base10 == 0) // End early { break; } } 在輸出時使用 API 提供的函式格式化。 cout \u003c\u003c setiosflags(ios::fixed) \u003c\u003c setprecision(8); 使用 GDB 進行調試，這樣能快速找到代碼問題。 ","date":"2019-10-11","objectID":"/c-_solving_decimal_programming/:4:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/c-_solving_decimal_programming/"},{"categories":["C/C++"],"content":"Functions int main() ：主程序 double Scan(string, int *)：輸入 string 的小數，轉換成 double 類型，並計算輸入小數的小數位數 bool isValid(double, int, int)：判斷輸入的小數是否符合 base-S 進制 void convert(double, int, int, double *, double *, int)：先將小數轉成 10 進制，再轉成 base-D 進制 ","date":"2019-10-11","objectID":"/c-_solving_decimal_programming/:5:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/c-_solving_decimal_programming/"},{"categories":["C/C++"],"content":"流程圖 此圖為我設計的流程圖。 註：不知道為什麼我從 draw.io 導出的圖片在 linux 下會跑版，格式亂了╮(╯_╰)╭ 最後只好使用截圖工具 繪製流程圖1.png \" 繪製流程圖 ","date":"2019-10-11","objectID":"/c-_solving_decimal_programming/:6:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/c-_solving_decimal_programming/"},{"categories":["C/C++"],"content":"源代碼 這裡還是強調一下，寫代碼時註解真的很重要，你的代碼不僅是要你自己可以快速釐清自己的代碼，不然一段時間後自己再看自己寫的內容又看不懂，而且要讓看你代碼的人能看懂。 #include\u003ciostream\u003e#include\u003cmath.h\u003e#include\u003ciomanip\u003e#include\u003cstring\u003e#include\u003cstdlib.h\u003e using namespace std; double Scan(string, int*); // count significant bool isValid(double, int, int); // Judge the number's correctness (Base-S) void convert(double, int, int, double *, double *, int); // convert the number from Base-S to Base-D and Base-10 int main() { // initialize double number = 0; // The number we need to input int S = 0; // base-S int D = 0; // base-D char isQuit = 'C'; // Judge whether to leave double convert1 = 0, convert2 = 0; // the result from convert() string count; // The number we need to input int significant = 0; // the number's significant // loop, if isQuit's value is 'Q',break it. while(isQuit == 'C') { // description cout \u003c\u003c \"Base conversion for numbers [0,1) with at least 8 significant digits.\\n\"; cout \u003c\u003c \"Convert a number from base-S to base-D (2\u003c=S\u003c=10, 2\u003c=D\u003c=10):\\n\"; // input Base-S cout \u003c\u003c \"Input S: \"; cin \u003e\u003e S; // input Base-D cout \u003c\u003c \"Input D: \"; cin \u003e\u003e D; fflush(stdin); // loop while(1) { // input number cout \u003c\u003c \"Input a valid base-\" \u003c\u003c S \u003c\u003c \" number: \"; // cin \u003e\u003e number; number = Scan(count, \u0026significant); if(isValid(number, S, significant)) // number is valid { break; } else // number is invalid { cout \u003c\u003c \"Error: \" \u003c\u003c setiosflags(ios::fixed) \u003c\u003c setprecision(8) \u003c\u003c number \u003c\u003c \" is an invalid base-\" \u003c\u003c S \u003c\u003c \" number\\n\"; } } convert(number, S, D, \u0026convert1, \u0026convert2, significant); // convert // output the result cout \u003c\u003c setiosflags(ios::fixed) \u003c\u003c setprecision(8) \u003c\u003c number \u003c\u003c \"(\" \u003c\u003c S \u003c\u003c\") is equivalent to \" \u003c\u003c convert1 \u003c\u003c\"(10) \u0026 \"\u003c\u003c convert2 \u003c\u003c\"(\"\u003c\u003c D \u003c\u003c \")\"\u003c\u003cendl; // input isQuit cout \u003c\u003c \"Process another Conversion or Quit? (C/Q) -\u003e \"; cin \u003e\u003e isQuit; // Letters into uppercase isQuit = toupper(isQuit); // initialize the values convert1 = 0; convert2 = 0; significant = 0; } system(\"pause\"); return 0; } double Scan(string count, int *significant) { *significant = 0; double number = 0; // we need to enter int N = -1; cin \u003e\u003e count; // enter the string fflush(stdin); for(int i = 2; i \u003c count.length(); i++) // use count's length to loop { *significant += 1; // count significant number += (count[i] - '0') * pow(10, N); // char -\u003e double N -=1; } return number; } bool isValid(double number, int S, int significant) { double swapDouble = 0; // Continuously taking decimal places for(int i = 0; i \u003c significant; i++) { number *= 10; if((int)number \u003e= S) // not meets Base-S { return false; // invalid } else { swapDouble = (double)((int)number); number -= swapDouble; } } return true; // valid } void convert(double number, int S, int D, double *convert1, double *convert2, int significant) { int n = -1; // the power of n double base10 = 0; // copy convert1 // Continuously taking decimal places // convert to base-10 /* Reference https://notfalse.net/17/positional-numeral-systems-conversion */ for(int i = 0; i \u003c significant; i++) { number *= 10; *convert1 += (int)number * pow(S, n); // e.g. 1.1 (base-2) -\u003e 1*2^0 + 1*2^(-1) = 1.5 (base-10) number -= (int)number; n -= 1; } base10 = *convert1; // copy n = -1; // init // Continuously taking decimal places // convert base-10 to base-D /* Because the precision of double is 16 , so multiply it by 17 and execute at least 17 times, otherwise it will enter an infinite loop. Reference https://www.cnblogs.com/upzone/articles/1389365.html */ for(int i = 0; i \u003c 17; i++) { base10 *= D; *convert2 += (int)base10 * pow(10, n); base10 -= (int)base10; n -= 1; if(base10 == 0) // End early { break; } } } ","date":"2019-10-11","objectID":"/c-_solving_decimal_programming/:7:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/c-_solving_decimal_programming/"},{"categories":["C/C++"],"content":"運行結果 運行結果6.png \" 運行結果 ","date":"2019-10-11","objectID":"/c-_solving_decimal_programming/:8:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/c-_solving_decimal_programming/"},{"categories":["C/C++"],"content":"結論 測試輸入測資，輸出與測資結果相同。 相信這題能幫助許多人能對小數進制轉換這類題目有所了解，並增進程序設計中的核心 – 演算法。祝各位學習順利，我也建議各位多主動做題目，積極去學習，這樣才會有所成長。 ","date":"2019-10-11","objectID":"/c-_solving_decimal_programming/:9:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/c-_solving_decimal_programming/"},{"categories":["C/C++"],"content":"Reference [C\u0026C++] 浮點數精準度 (Floating-Point Precision) - 逍遙文工作室 進制轉換 (二進制、八進制、十進制、十六進制) - NotFalse 技術客 十进制小数转二进制小数方法 ","date":"2019-10-11","objectID":"/c-_solving_decimal_programming/:10:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/c-_solving_decimal_programming/"},{"categories":["ArchLinux"],"content":"前言 我分享一下如何安裝 Arch Linux 的方法，因為我之前裝 Arch Linux 時踩了很多坑，加上我是小白，所以遇到的問題很多，我會在這篇文章中教導各位如何安裝 Arch Linux 在各位的電腦，優雅地使用 Arch Linux 發行版，這篇文章是面向小白向的教學文，這篇只會提及如何安裝，至於初始化與其餘部份會另外寫篇文章。 由於我的電腦型號是聯想 y7000，所以遇到的坑真的很多，我會按特殊情況講解，雖然 Installation guide - ArchWiki 的安裝指南已經很詳細了，但對於剛接觸的新手根本是火星文 :( 因為我這是專給小白寫的文章，所以寫了很多細節和注意點，如果你是高手，覺得我寫了很多廢話，那請你忍耐吧，也可以選擇不看我的文章，直接去看 ArchWiki。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:1:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"安裝前準備 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"1. 至 清華大學 Archlinux 軟件鏡像站下載最新版的 archlinux*.ios 鏡像 清華大學鏡像站1.png \" 清華大學鏡像站 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"2. 下載 Rufus - 用來匯入 Archlinux 鏡像至 USB Refus 官網2.png \" Refus 官網 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"3. 準備一個至少 8G 的 USB 使用 Rufus 將 Arch 鏡像匯入在目標 USB 裝置。 註：在此只需修改您的目標 USB 和鏡像源即可，按下開始鍵進行匯入。 關於燒錄方式 2020/01/21 補充燒錄方式。 我幫家裡已經十年的 HP CQ40 重裝系統，因為過於老舊，電腦沒有 UEFI，只有 Legacy，所以開機無法以 UEFI 開機，這時關於燒錄鏡像的方式就需要做調整。 如果你的 Bios 有 UEFI 就使用 GPT 燒錄，如果是像我上面一樣，電腦過於老舊，當時的年代只有 Lengcy，這時你需要使用已經淘汰的 MBR 燒錄鏡像，然後建議使用 dd 燒錄。至於怎麼看自己電腦有沒有 UEFI，只需要查看自己的 Bios 是否有開機模式選項並且有 UEFI 選項。 現在大部份的電腦都有 UEFI，所以正常選擇 GPT 就好。 e.g. MBR 燒錄。 MBR 燒錄3.png \" MBR 燒錄 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"4. 分割磁區 我們假設在固態硬碟割出 40GB 空間（40GB root），在虛擬硬碟割出102GB 空間（2GB swap, 100GB home），此時別格式化割出來的磁區，讓它們保持為未配置狀態。 在 Windows 工作列的 win 圖標上點擊滑鼠右鍵選擇磁區管理，將自己的磁區切割，現在大部份的電腦是 110GB 左右的固態 SSD 和 1TB 左右的虛擬硬碟，當然少部份例外，我建議固態硬碟割出至少 40GB 給 /root 根目錄（類似 Windows的 C槽），接著可以在虛擬硬碟割出 100GB 以上給 /home 家目錄，也有特殊情況，像我的室友他電腦只有固態 SSD 所以只能割固態硬碟給 /home，我室友我幫他割了 30GB 給 /root，40GB 給 /home，2GB 給 swap。 註：我強烈不建議將 Linux 灌在 USB 上或是像移動固態 SSD 等移動裝置上，首先在啟動上很不方便，每次都要進入 BIOS 調整開機順序，又容易電腦卡頓，電腦容易發燙，加上電源的耗電速度快等因素，其實我就在我室友的移動固態 SSD 上嘗試過，甚至安裝失敗，連圖形界面都進不去。 磁區管理示意圖： Windows 磁區管理4.png \" Windows 磁區管理 在磁區上點擊滑鼠右鍵選擇壓縮磁碟，應你的需求壓縮適當大小的磁區。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"5. USB 使用 UEFI 方式開機 進入 BIOS，調整 Boot 開機順序，改為你的 USB 優先開機，主機與 USB 開機模式為 UEFI 每台電腦進入 BIOS 的方法都不同，像我的電腦是聯想 y7000，所以我在開機時一直按住 Fn + F2 ，就能進入 BIOS 調整開機順序，因為幫室友們裝了 Arch，所以 ThinkPad 是 F1，華碩是按 Esc 或 F2，小米是 F2，我記得小米筆電進入 BIOS 還需要輸入 Password，有點麻煩就是了。當然還是勸大家上網搜一下自己電腦型號的進入 BIOS 快捷建。不好意思，我因為 linux 無法掛載我的移動 SSD，具體是因為我之前想將 arch 灌到 SSD 上，後來覺得使用上麻煩所以放棄了， 所以我先將該磁區刪除再新增， 成功進入 USB 後選擇第一個選項 Boot Arch Linux (X86_64) 按 Enter 進入，當你看到 root # 就代表你已經進入 USB 裡的 Arch 安裝鏡像。 註：切記要是 UEFI 開機，因為我們最後要在 BIOS 安裝引導程序，來引導我們開機選擇進入的 OS。如果沒有使用 UEFI 開機的話會裝不上引導程序 grub。 當然如果你的電腦沒辦法使用 UEFI，並且前面的燒錄方式使用的是 MBR，在後面分割磁區時就需要用不同的方式，然後 GRUB 引導也是不同的指令。 Arch Linux Live CD5.png \" Arch Linux Live CD ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:5","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"6. 確認連到網路 在安裝過程我們需要用到網路，我們需要確認我們連的到網路，輸入以下指令 ping baidu.com # 確認是否可連上百度 如果你的結果與下圖相同則代表你已連上了網路，按下 Ctrl + C 中止命令， ping 指令測試連網6.png \" ping 指令測試連網 如果無法從 baidu.com 接收 packets，掉包率（packets loss）100%，代表你沒有連上網路，這時我建議插網線連有線網路，不建議連無線網路，因為在無線網路使用上會出些問題，不建議新手使用，我最常用的方法是將使用數據線將電腦與手機連結，然後手機開 USB 共用網路，手機可以連行動數據或 WiFi 給電腦網路。 1.插上網線 ip link #顯示自己的網路接口 顯示網路接口7.png \" 顯示網路接口 enp7s0 是我的有線接口，wlp0s20f3 是我的無線接口，當然這些接口名稱會隨著電腦不同而不同但大多相似。 ip link set enp7s0 up # 將有線接口打開 dhcpcd enp7s0 # 連接接口 ping baidu.com # 再測試一次是否連網 以上如果沒問題就可跳過用手機共用網路步驟 2.用數據線將手機與電腦連結，並開啟 USB 共用網路 輸入 ip link 後出現了新的有線接口 enp0s20f0u1，此為你的手機網路接口。 註：通常自己電腦的有線網路接口名稱比手機的網路接口名稱短。 手機網路接口8.png \" 手機網路接口 ip link set enp7s0 down # 關閉自己電腦的有線接口 ip link set enp0s20f0u1 up # 開啟手機的有線接口 dhcpcd enp0s20f0u1 # 連接手機的有線接口 ping baidu.com # 測試是否連上網路 通常到這裡網路是連上的，如果還連不上那可能就要連無線 WiFi 了，我就不多說明了，可以參考 Wireless network configuration (简体中文) - ArchWiki 和 某網友的 Blog 和 某教程網 有提及，因為之前我幫我朋友安裝 Archlinux 時要連無線 WiFi 時搞了很久，還出了錯誤，最後直接使用手機的共用網路才解決。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:6","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"7. 更新系統時間 使用 timedatectl 確保系統時間是準確的，後面我們在同步數據庫時需要系統時間與網路時間的同步。 註：這一步真的很重要，我之前因為忘了這一步驟導致數據庫無法同步，開啟時間同步後還要進入 Chroot 重裝一次系統 pacman -S linux timedatectl set-ntp true # 開啟時間同步 timedatectl status # 檢查服務狀態 查看系統時間9.png \" 查看系統時間 請確保 NTP service 狀態為 active，且確定自己的系統時間是否正確。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:7","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"8. 分割磁區 我們使用 cfdisk 來分割磁區 ArchWiki 建議的分區參考 ArchWiki 建議的磁區分區10.png \" ArchWiki 建議的磁區分區 我們已經在 Windows 分割好了我們的磁區。我們使用的是 GPT 的方案。 lsblk # 檢查磁區狀態 檢查磁區分區情況11.png \" 檢查磁區分區情況 以上是我的磁區狀態，因為我是已經裝好了系統，所以會顯示這樣的狀態，但你現在的狀態是不會顯示出你切割出來的磁區，這裡記得你的磁區大小以便在這裡辨認出你的磁區哪些是固態硬碟和虛擬硬碟。 註：有些指南標示 /dev/sdX 的 sdX 意思是你的磁區代號，有些電腦的固態硬碟代號是 sdb 或是 nvme0n1，虛擬硬碟通常代號是 sda，你可以將 sdX 當成一個代稱，因為沒人保證你電腦裡的硬碟的代號為何，像我有個室友他電腦的固態硬碟是 sdb。 在輸入路徑時可以搭配 Tab 鍵快速輸入，輸入開頭先按一次 Tab，如果指令行下出現許多路徑可按兩次 Tab 選取。 在這裡我們假設你的固態硬碟是 nvme0n1 - 割出 40GB 給 root，虛擬硬碟是 sda - 割出 102GB。輸入以下指令進入管理磁區界面。 cfdisk /dev/nvme0n1 # 管理固態硬碟磁區 管理固態硬碟磁區12.png \" 管理固態硬碟磁區 這裡是管理你的固態硬碟界面。先使用上下鍵調到你割出來的 Free Space 40GB，左右鍵調到 New 按下 Enter，輸好要分配出的大小再按 Enter 將空間分配出來，接著左右鍵調到 Type，選取 Linux root (ARM-64)，這是 64 bit 的系統，如果你的電腦是 32 bit 請選擇 Linux root (X86)，接著確認你的磁區上面有個磁區類型是 EFI System ，並記住磁區代號或大小，這裡是要掛載 boot 的磁區，如果沒有的話請找到可以自己在割出大概從某個磁區割出 250MB 調整類型為 EFI System 分區。接著左右鍵調到 Write 寫入設定，輸入 yes 按下 Enter，確認無誤後可以按下 Quit 離開此界面，再次 輸入 lsblk 就可以在 /dev/nvme0n1 看到你分割出的空間了。 註：記得一定要寫入，我之前很多次都忘了寫入，重搞了幾次。 cfdisk /dev/sda # 管理虛擬硬碟磁區 示意圖我就不放了，方式都跟上個步驟大同小異，分別割出 2GB Type 為 Linux Swap 和 100GB Type 為 Linux home 的分區。 註：有些人的電腦可能沒有我上述講的類型，如果找不到 Linux root (ARM-64)、Linux root (X86)、Linux home，可以將 Type 改成 Linux filesystem，只是 EFI System 與 Linux swap 不能這樣搞，而且這兩類型是找得到的。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:8","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"9. 格式化磁區 當分區建好後，我們需要對此格式化。每種類型的磁區格式化方式都不相同。 註：我們假設你分割出的 40GB 固態硬碟空間磁區代號為 nvme0n1p5，boot 為 nvme0n1p1，2GB Swap 為 sda3 ，100GB home 為 sda4。 註：mkfs.ext4 的創建方式與 mkfs.fat 的差別在於前者有創建 journal 日誌，後者沒有。注意：文件系統一定要創建日誌，不然個人的資料可能會造成損失等後果。 文件系統 root 與 home 關於文件系統可以建議裝 xfs 或是 btrfs。我會在後面的重要補充的地方說明。 mkfs.ext4 /dev/nvme0n1p5 #格式化 root mkfs.ext4 /dev/sda4 #格式化 home EFI 系統分區 boot mkfs.fat -F32 /dev/nvme0n1p1 # 格式化 boot 置換空間 swap mkswap /dev/sda3 # 格式化 swap swapon /dev/sda3 # 掛載置換空間 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:9","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"10. 掛載分區 因為根目錄 /mnt 已在你的 USB 存在，所以不需要創建。注意：必須優先掛載 /mnt 再掛載其它目錄。 mount /dev/nvme0n1p5 /mnt # 掛載根目錄 root mkdir /mnt/boot # 創建 /boot 目錄 mount /dev/nvme0np1 /mnt/boot # 掛載 /boot mkdir /mnt/home # 創建 /home 目錄 mount /dev/sda4 /mnt/home # 掛載 /home lsblk # 查看分區無誤 掛載好後，接下來 genfstab 將會自動檢測掛載的文件系統和置換空間。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:10","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"安裝 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:3:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"1. 選擇鏡像 編輯 /etc/pacman.d/mirrorlist 文件，將你的所在的鏡像地址優先排在前面，在列表中越前面的地址修先級越高。 vim /etc/pacman.d/mirrorlist # 編輯文件 關於 Vim 的編輯指令可參考 超簡明 Vim 操作介紹，用起來其實不難。 超簡明 VIM 編輯指令13.png \" 超簡明 VIM 編輯指令 關於 Vim 移動整行的指令 :12, 13 move 6 # 將第 12, 13 行剪貼至第 6 行 像我目前所在的地區為 China，所以我將 China 的鏡像源都移至最開頭。 編輯鏡像列表14.png \" 編輯鏡像列表 編輯好並確認無誤後退出 Vim 編輯器。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:3:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"2. 安裝基本系統 使用 pacstrap 腳本安裝 base 組： 註：在這裡請務必確認你的 /boot 是掛載在 EFI Syetem 分區上，不然後面需要進入 Chroot 執行 pacman -S linux 重裝系統。 ping baidu.com # 確認此時你是連上網的 pacstrap /mnt base linux linux-firmware # 安裝基本系統 如果你是第二次裝 ArchLinux 的小夥伴，你執行以上指令可能會遇到下載完後安裝時，顯示 /boot/vmlinuz-linux 已存在，所以無法安裝，這時執行以下指令。 rm /boot/vmlinuz-linux # 刪除該檔案 pacstrap /mnt base linux linux-firmware # 安裝基本系統 註：pacstrap 的安裝指令我在 2020/01/04 更新，因為幫同學重灌 ArchLinux 時發現指令變了，目前最新本的 ArchLinux 發行版指令是 pacstrap /mnt base linux linux-firmware。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:3:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"配置系統 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"1. Fastab 執行以下指令生成 fstab 文件（用 -U 或 -L 選項設置 UUID 或卷標）。 genfstab -U /mnt \u003e\u003e /mnt/etc/fstab # 生成 fstab 文件 我個人強烈建議生成完 fstab 後使用 Vim 查看內容，尤其是重裝 Arch 和重新分配磁區的人一定要查看這份文件。 註：我之前因為將 /root 掛載在虛擬硬碟，所以在 Linux 環境下電腦特別卡，在重灌一次後因為沒有重新砍掉 fstab 文件生成一次，所以上一次安裝時的設定即使執行生成 fstab 文件指令，還是會保留設定無法去除，只是添加了設定，無法覆蓋源設定，造成第二次還是那麼卡。 vim /mnt/etc/fstab # 查看 fstab 文件 請確認這份文件裡只有四份資料（如果有多分割幾個磁區，就可能不是只有四份，你掛載幾個目錄就有幾份資料，不能多不能少）。 fstab 內容 tabletable.png \" fstab 內容 table fastab 內容15.png \" fastab 內容 如果你的文件有問題且資料混亂執行以下指令。 rm /mnt/etc/fstab # 移除原文件 genfstab -U /mnt \u003e\u003e /mnt/etc/fstab # 生成 fstab 文件 再次用 Vim 確認無誤之後，就可進入下一步。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"2. 進入 Chroot Change root 到新安裝的系統，顧名思義就是進入電腦以安裝好的系統，目前我們所在的地方是 USB，如果沒進入 Chroot 就進行安裝和設定就等於安裝和設定在你的 USB 上。 註：如果重裝系統或是需要重新插上 USB 做些設定，像我通常就發生在磁區分割錯誤或目錄掛載錯誤或 Windows 系統更新後引導程序設定檔被砍，需要先將所有的分區先掛載，再進入 Chroot 才會顯示你電腦裡的磁區，再次強調，先掛載 /mnt。 arch-chroot /mnt # 進入 Chroot ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"3. 時區 設置時區，Region 為你所在的洲，City 為你所在城市。 ln -sf /usr/share/zoneinfo/Region/City /etc/localtime # 設置時區 我設定的是台北時間。 ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime 執行 hwclock 生成 /etc/adjtime。 hwclock --systohc # 生成 /etc/adjtime 這個指令假定硬件時間已經設置為 UTF 時間。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"4. 添加本地語系 註：進入 arch-chroot 後需要將 nano 和 vim 裝上去，pacman -S nano vim，這樣才能使用這些工具。 編輯 locale.gen 把自己要用的語言註解去掉，也就是去掉開頭的 #，一定要取消註解 en_US.UTF-8 UTF-8，建議取消註解帶 UTF-8 的語言，把 GBK 和 BIG5 註解去掉可以支援更多字。 nano /etc/locale.gen # 編輯 locale.gen 以下是我要取消註解的語言，因為我繁體字和簡體字都很常用。 en_US.UTF-8 UTF-8zh_CN.GB18030 GB18030zh_CN.GBK GBKzh_TW.EUC-TW EUC-TWzh_TW.UTF-8 UTF-8 執行 locale-gen 生成 locale 訊息。 locale-gen # 生成 locale 訊息 接著創建 locale.conf 檔案並編輯 LANG 這一個語言環境環境變量為英語 en_US.UTF-8，如果你設為中文的話會造成 tty 出現亂碼。 vim /etc/locale.conf # 創建並編輯 locale.conf 修改語言環境。 LANG=en_US.UTF-8 # 變量設為英語 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"5. 主機名稱與網路 創建 hostname 文件設置你的主機名稱。 vim /etc/hostname # 創建 hostname 文件 直接在 hostname 填入你主機名稱，myhostname是你的主機名。 myhostname # 你的主機名稱 添加對應訊息到 hosts(5)。 vim /etc/hosts # 編輯 hosts 寫入以下內容，將 myhostname 修改成你前面設定的主機名稱。 註：如果系統有一個永久的 IP 地址，請使用這個永久的 IP 地址，而不是 127.0.1.1。 像我就沒有設永久 IP，所以直接編輯成以下內容。 127.0.0.1 localhost::1 localhost127.0.1.1 myhostname.localdomain myhostname ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:5","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"6. Initramfs 創建 Initramfs，這是用來將內存盤初始化的腳本，例如開關機時掛載與卸載磁區，現在 Initramfs已取代了舊版的 initrd。 mkinitcpio -p linux # 創建 Initramfs 如果你想深入了解 Initramfs，可以參考 mkinitcpio (简体中文) - ArchWiki 和 Initramfs/指南 - gentoo linux。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:6","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"7. 設定 Root (超級使用者) 密碼 設定 Root 超級使用者的密碼，超級使用者的意思就是這個用戶相當於系統管理員，擁有修改系統設定的所有權力。 輸入以下指令後會要求你輸兩次密碼，第二次是確認你的密碼正確，輸入密碼時文字是隱藏的，所以不用慌張以為沒有輸入進去。 passwd # 設定密碼 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:7","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"8. 安裝引導程序 因為我之前裝的引導程序是 rEFInd，但 rEFInd 實在太不穩了，好幾次隨著 Windows 更新而設定檔被砍進不了 Linux，需要重裝，然後我朋友推薦給我使用直接裝在 BIOS 的 grub，穩定不容易被砍，雖然界面比 rEFInd 丑了很多，但至少穩定。 grub 是引導程序，os-prober是可以偵測其他操作系統的軟體包，efibootmgr可以操控 UEFI 固件啟動管理器設置的工具。 註：請確定你是以 UEFI 模式開機，不然會一直報錯 efi variables are not supported on this system。這時你就必須重新開機進入 BIOS 調整開機模式再進到 Arch Linux 安裝碟安裝 grub。也請確定你的 Boot 是掛載在 EFI System 磁區，不然你無法產生 grub 設定檔，原因在於我們是要掛載在 Boot，但因為 Boot 沒掛載到 EFI 磁區，所以在 EFI 磁區找不到 Boot，產生路徑錯誤。 sudo pacman -Syu # 現在更新一下系統 sudo pacman -Syy # 同步數據庫 sudo pacman -S grub os-prober efibootmgr # 下載軟體包 接著把 grub 安裝到 EFI System 磁區，將以下指令--efi-directory 的 esp 改為你的 grub 掛載點，我們要將 grub 掛載到 /boot 上，所以 esp 改為 /boot。 指令格式 grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=grub 我的掛載方式 grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub 然後掛載你的 Windows 磁區，你的固態硬碟 C 槽磁區，沒掛載的話到時候產生設定檔會找不到你的 Windows。 mkdir /mnt/windows # 創建 C 槽目錄 mount /dev/sdaX1 /mnt/windows # 掛載到目標磁區 當然如果你還想讀取其它 Windows 的磁區，你可以現在順便掛載好，當然後面再掛載也行。 現在我想將我的虛擬硬碟 Wiindows 的 D 槽掛載。 mkdir /mnt/Data # 創建 D 槽目錄 mount /dev/sdaX2 /mnt/Data # 掛載到目標磁區 然後產生 grub 設定檔。 grub-mkconfig -o /boot/grub/grub.cfg 確認設定檔產生無報錯後接著退出 Chroot。 exit # 退出 Chroot ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:8","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"重要補充 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:5:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"MBR 的 GRUB 引導指令 sdX 為 /root 的磁區。 grub-install --target=i386-pc /dev/sdX ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:5:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"雙 Arch 系統 2020 / 02 / 05 補充 我想有些人會為了腦熱或好奇心而裝三系統，像我室友是 Windows + 兩個 Arch，這時引導 grub 的設置就顯得重要。 在做這三系統時，你必須確保你兩個 Arch 的系統不是共用一個 /boot，然後你只需要在其中一個 Arch 系統中設置安裝 GRUB。 你在其中一個 Arch 系統中執行完上述的步驟產生出 grub.cfg 設定檔後，我們開始我們設定我們的 GRUB 設定檔。 查看 UUID 你需要將你另一個 Arch 系統 /root 和 /boot 的 UUID 記住。像我的 root 的 UUID 是 a48c597a-d1f2-4f4a-82f8-ba96114912f1、boot 的 UUID 是 1258-CD76。 lsblk -f # 檢查各磁區 UUID # 以下是輸出結果 NAME FSTYPE FSVER LABEL UUID FSAVAIL FSUSE% MOUNTPOINT sda ├─sda1 ├─sda2 ntfs DATA FEBCDBDCBCDB8D91 ├─sda3 ext4 1.0 bcdb5959-181b-4a68-94e3-f5b79c0a14a8 55.1G 37% /home └─sda4 swap 1 867cc6ea-05af-4676-b36f-875dd7570a38 [SWAP] nvme0n1 ├─nvme0n1p1 vfat FAT32 SYSTEM_DRV 1258-CD76 164.3M 36% /boot ├─nvme0n1p2 ├─nvme0n1p3 ntfs Windows 46DA5983DA597063 ├─nvme0n1p4 ntfs F4B6F775B6F73728 └─nvme0n1p5 ext4 1.0 a48c597a-d1f2-4f4a-82f8-ba96114912f1 2.3G 87% / 編輯 GRUB 設定檔 紀錄後，就編輯 /boot/grub/grub.cfg。 vim /boot/grub/grub.cfg 加上以下內容，並將下面所有的 rootUUID 和 bootUUID 分別改成你另一個 Arch 系統的 /root 和 /boot 的 UUID。至於開頭的 Arch Linux 可改成自己想取的名字。Advanced options for Arch Linux 也改成你自己想取的名字。 menuentry 'Arch Linux' --class arch --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simple-rootUUID' { load_video set gfxpayload=keep insmod gzio insmod part_gpt insmod fat if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root bootUUID else search --no-floppy --fs-uuid --set=root bootUUID fi echo 'Loading Linux linux ...' linux /vmlinuz-linux root=UUID=rootUUID rw loglevel=3 quiet echo 'Loading initial ramdisk ...' initrd /initramfs-linux.img } submenu 'Advanced options for Arch Linux' $menuentry_id_option 'gnulinux-advanced-rootUUID' { menuentry 'Arch Linux, with Linux linux' --class arch --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-linux-advanced-rootUUID' { load_video set gfxpayload=keep insmod gzio insmod part_gpt insmod fat if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root bootUUID else search --no-floppy --fs-uuid --set=root bootUUID fi echo 'Loading Linux linux ...' linux /vmlinuz-linux root=UUID=rootUUID rw loglevel=3 quiet echo 'Loading initial ramdisk ...' initrd /initramfs-linux.img } menuentry 'Arch Linux, with Linux linux (fallback initramfs)' --class arch --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-linux-fallback-rootUUID' { load_video set gfxpayload=keep insmod gzio insmod part_gpt insmod fat if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root bootUUID else search --no-floppy --fs-uuid --set=root bootUUID fi echo 'Loading Linux linux ...' linux /vmlinuz-linux root=UUID=rootUUID rw loglevel=3 quiet echo 'Loading initial ramdisk ...' initrd /initramfs-linux-fallback.img } } ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:5:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"連網 因為拔掉 USB 重啟電腦後，會發現關於連網功能不好處理，使用 ip link 後 dhcpcd 過於繁瑣，建議就在這裡就安裝連網的管理器。 註：在 Chroot 中無法使用 systemctl，所以要等全部裝完後再啟用。 arch-chroot /mnt # 進入 Chroot pacman -S networkmanager # 安裝 networkmanager exit # 退出 Chroot ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:5:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"不裝雙系統，只有 Linux 如果你是將所有電腦裡的系統都砍了只裝 Archlinux，你一樣要裝引導，像之前我幫一個朋友裝 ArchLinux 時他將自己電腦上的 Windows 全砍了，剩下所有空間都給 Linux。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:5:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"文件系統 XFS 與 Btrfs 2020 / 02 / 05 補充文件系統 XFS 和 Btrfs。 2020 / 07 / 29 更新，我已經用上 Btrfs，真香，讀寫速度變很快。 因為我文件系統使用 ext4 使用 ntfs-3g 寫入時非常慢，甚至卡頓，我在這裡推薦使用 XFS 或是 Btrfs。但是 Btrfs 還不夠穩定，所以我這裡是推薦 XFS。 XFS 是一種高性能的日誌文件系統，XFS 特別擅長處理大文件，同時提供平滑的數據傳輸。當前 CentOS 7 也將 XFS + LVM 作為默認的文件系統。 Btrfs 是一種用於 Linux 的新的寫時複製文件系統，旨在實現高級功能，同時專注於容錯、修復和輕鬆的管理。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:6:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"XFS mkfs.xfs /dev/nvme0n1p5 #格式化 root mkfs.xfs /dev/sda4 #格式化 home 在安裝 base 時要輸入以下內容，將 xfsprogs 包加入： pacstrap /mnt base linux linux-firmware xfsprogs 更多請參考 XFS (简体中文) - ArchWiki。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:6:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"Btrfs mkfs.btrfs -L arch-root /dev/nvme0n1p5 #格式化 root mkfs.btrfs -L arch-home /dev/sda4 #格式化 home 在安裝 base 時要輸入以下內容，將 btrfs-progs 包加入： pacstrap /mnt base linux linux-firmware btrfs-progs 更多請參考 Btrfs (简体中文) - ArchWiki。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:6:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"重啟電腦 因為我手速不夠快，如果不小心在還沒完全關機或已經開機狀態下拔下 USB，會造成嚴重錯誤，所以我選擇直接關機再手動開機。 reboot # 重開機 poweroff # 直接關機 關機後立刻將 USB 拔出電腦，然後開機，如果開機沒有進入 grub，重開機一次進入 BIOS 會看到 有 grub 的開機選項，將這個選項調到最優先開機就行了。 登入時輸入 user 為 root，password 為你之前設的 Root 密碼。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:7:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"安裝後工作 我會之後會寫 Arch Linux 安裝後文章，並放入 Blog。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:8:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"Reference Installation guide (简体中文) - ArchWiki 超簡明 Vim 操作介紹 - 為你自己學 Git 请问vim如何移动当前行向上或向下？不用选中 - V2EX EFI system partition (简体中文) - ArchWiki Network configuration (简体中文) - ArchWiki mkinitcpio (简体中文) - ArchWiki Initramfs/指南 - gentoo linux Localization/Simplified Chinese (简体中文) - ArchWiki Unified Extensible Firmware Interface (简体中文) - ArchWiki GRUB (简体中文) - ArchWiki Linux文件系統格式有哪些類型？選錯你就要辭職了 - 今日頭條 XFS (简体中文) - ArchWiki Btrfs (简体中文) - ArchWiki ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:9:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"前言 相信我，肥宅我看了很多網站上教學，都是老舊的廢文，甚至如果照做就有可能造成出錯的問題。還有很多文章也沒有詳細講解該如何配置，關於 Linux 中的 GDB 配置在 VScode 的文章少之又少，錯誤百出。因此肥宅在這教導各位正確地在 Linux 環境下從安裝 VScode 到配置環境變量與 GDB 調試。 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:1:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"肥宅的 Linux 發行版資訊 肥宅使用的發行版是 ArchLinux，圖形界面是 KDE Plasma。 系統資訊1.png \" 系統資訊 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:2:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"下載安裝 VScode ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:3:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"在 Konsole 輸入下載指令 sudo pacman -S code 註：因爲圖形界面的使用者一定是一般使用者，不可能是超級使用者，所以在輸 pacman 前面要加上 sudo。 安裝 VScode2.png \" 安裝 VScode 輸入 y 並按下 Enter。 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:3:1","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"下載 GCC GDB 註：肥宅是在 Windows OS 用習慣了 MinGW-w64，但在 Linux 這樣配置並不是很好的選擇，如果你使用 GCC 或 Clang 會跟 Linux 兼容性高。MinGW-w64 軟件包包含 gcc g++ GDB…等內容及 API。 在這裡肥宅使用 GCC 與 GDB ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:4:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"在 Konsole 輸入下載指令 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:4:1","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"GCC sudo pacman -S gcc 安裝 GCC3.png \" 安裝 GCC 輸入 y 並按下 Enter。 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:4:2","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"GDB sudo pacman -S gdb 安裝 GDB4.png \" 安裝 GDB 輸入 y 並按下 Enter。 補充： 註：有些小白可能不懂，在此肥宅附上 WIKI 連結 GCC-維基百科，自由的百科全書 Clang-維基百科，自由的百科全書 MinGW-維基百科，自由的百科全書 GDB-維基百科，自由的百科全書 什麼？！你還是不懂？ 你不會 GOOGLE 一下嗎5.png \" 你不會 GOOGLE 一下嗎 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:4:3","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"安裝 VScode 插件 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:5:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"安裝自己使用的語言並 Reload 在插件搜尋處搜尋自己要的語言，像肥宅我是用繁體中文，所以只要在搜尋處打上 traditional 就會出現安裝插件，按下 Install，並等它裝好 Reload就會切換到自己想要的語言界面，如果你想裝的是簡體中文，可以輸入 simplified，其實你只要輸入 Chinese 的 ch 基本繁體簡體都會顯示出來。 語言插件6.png \" 語言插件 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:5:1","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"安裝 C/C++ 插件 搜尋 C/C++ 並安裝 C/C++ 插件7.png \" C/C++ 插件 其餘插件推薦請參考 Visual Studio Code 推薦使用插件 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:5:2","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"VScode 一些設定參考 點擊左下角滾輪中的設定，再點擊右上角的 {}，可進入 settings.json。 設定文件8.png \" 設定文件 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:6:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"settings.json { \"workbench.colorTheme\": \"One Dark Pro\", \"workbench.iconTheme\": \"vscode-icons\", \"terminal.integrated.fontFamily\": \"Source Code Pro\", \"code-runner.runInTerminal\": true, \"code-runner.saveFileBeforeRun\": true, \"code-runner.clearPreviousOutput\": true, \"typescript.locale\": \"zh-TW\", \"code-runner.fileDirectoryAsCwd\": true, \"editor.fontLigatures\": true, \"editor.fontFamily\": \"'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback', 'Source Code Pro'\", \"terminal.integrated.rendererType\": \"canvas\", \"files.autoSave\": \"afterDelay\", \"editor.fontSize\": 16, \"C_Cpp.default.intelliSenseMode\": \"clang-x64\" } 註：肥宅有裝 code-runer 插件，所以設定中有這個 code-runner。這裡不需要各位去複製貼上，只是給大家參考肥宅用了那些主題與插件。像肥宅目前使用 One Dark Pro 佈置主題。 注意：第 5 行的設定很重要，因為當你裝完 code-runner 時預設是不能在終端機輸入，所以才將 code-runner.runInTerminal 參數設為 true ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:6:1","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"配置 GDB 調試 這時你的電腦已配置了 gcc g++ 的環境變數，但你並還沒將其 IDE 完全配好，如果沒配好會出現一些問題，像肥宅在寫 C 敲上 #include \u003cstdio.h\u003e 時底部會出現綠色的波浪線，因爲沒將頭文件 *.h 都載入，雖然不影響編譯執行，但總會覺得很礙眼，感覺有瑕疵，在這裡肥宅一次幫各位解決。 註：下圖為綠色波浪底線示意圖 綠色波浪底線9.png \" 綠色波浪底線 讓我們開始配置吧~ 註：建議各位將所有代碼集中在一個資料夾方便管理，並有序分類。 Code 分類10.png \" Code 分類 註：這裡使用的是 Dolphin 來檢視檔案，類似 Windows OS 的檔案總管，這裡就不介紹這個。 顯示隱藏的 file 和 directory11.png \" 顯示隱藏的 file 和 directory 註：資料夾名或檔案名開頭是 . 的話會隱藏的，e.g. .vscode .git ，必須開啟可以顯示的設定才能看到。 請於代碼根目錄（也就是你使用 VScode 打開的資料夾）先將隱藏的檔案可以顯示，這裡因爲是肥宅先配置好的所以才會看到 .vscode，請在這新建個資料夾，資料夾名叫 .vscode，並分別新建四個文件，分別是 註：像肥宅在 VScode 開啟的資料夾是 Study，所以肥宅在 Study 這個資料夾目錄中新增名為 .vscode 的資料夾，並進入此資料夾新建四個檔案 settings.json c_cpp_properties.json launch.json task.json 接著分別填入以下內容 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:7:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"settings.json { \"files.defaultLanguage\": \"cpp\", // ctrl+N新建文件后默认的语言 \"editor.formatOnType\": true, // 输入时就进行格式化，默认触发字符较少，分号可以触发 \"editor.formatOnSave\": true, // 每次存檔時，自動執行自動排版功能 \"editor.snippetSuggestions\": \"top\", // snippets代码优先显示补全 \"code-runner.runInTerminal\": true, // 设置成false会在“输出”中输出，无法输入 \"code-runner.executorMap\": { \"c\": \"cd $dir \u0026\u0026 gcc $fileName -o $fileNameWithoutExt \u0026\u0026 $dir$fileNameWithoutExt.out\", \"cpp\": \"cd $dir \u0026\u0026 g++ $fileName -o $fileNameWithoutExt \u0026\u0026 $dir$fileNameWithoutExt.out\" }, // 设置code runner的命令行 \"code-runner.saveFileBeforeRun\": true, // run code前保存 \"code-runner.preserveFocus\": true, // 若为false，run code后光标会聚焦到终端上。如果需要频繁输入数据可设为false \"code-runner.clearPreviousOutput\": false, // 每次run code前清空属于code runner的终端消息 \"C_Cpp.clang_format_sortIncludes\": true, // 格式化时调整include的顺序（按字母排序） \"C_Cpp.intelliSenseEngine\": \"Default\", // 可以为Default或Tag Parser，后者较老，功能较简单。具体差别参考cpptools扩展文档 } 註：在 Linux 中輸出檔的副檔名是 *.out，有別於 Windows 的 *.exe 注意：第八行與第九行的是 code-runner 插件的編譯執行命令行，因為是在 Linux 下編譯執行，所以肥宅在後面 fileNameWithoutExt 變數後面從 .exe 改成 .out，這樣在使用 code-runner 插件時幫你自動生成的輸出檔副檔名是 *.out ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:7:1","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"c_cpp_properties.json { \"configurations\": [ { \"name\": \"Linux\", \"includePath\": [ \"${workspaceFolder}/**\", \"/usr/include\", \"/lib64/gcc/x86_64-pc-linux-gnu/8.2.1/include/\" ], \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"gcc-x64\", \"defines\": [ \"_DEBUG\", \"UNICODE\", \"__GNUC__=7\", \"__cdecl=__attribute__((__cdecl__))\" ], \"browse\": { \"path\": [ \"${workspaceFolder}\", \"/usr/include\", \"/lib64/gcc/x86_64-pc-linux-gnu/8.2.1/include/\", \"/lib64/gcc/x86_64-pc-linux-gnu/8.2.1/include-fixed/\", \"/lib64/gcc/x86_64-pc-linux-gnu/8.2.1/install-tools/include/\" ], \"limitSymbolsToIncludedHeaders\": true, \"databaseFilename\": \"\" } } ], \"version\": 4 } 註：肥宅之前就是這裡沒配置好（第 5 行的 \"includePath\"）所以才會在 #include \u003cstdio.h\u003e 這行底部出現綠色波浪 注意：肥宅 GCC 的版本是 8.2.1，所以如果你的版本改跟我不一樣請修改成你的當前版本，這裡最重要的是路徑不能有錯。也許你的路徑可能跟我不一樣，這些都可以在 root 根目錄中找到，請自行尋找與修改。 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:7:2","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"launch.json { // 使用 IntelliSense 以得知可用的屬性。 // 暫留以檢視現有屬性的描述。 // 如需詳細資訊，請瀏覽: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Run C\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/${fileBasenameNoExtension}.out\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": false } ], \"preLaunchTask\": \"build \u0026 run file C\" }, { \"name\": \"Run C++\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/${fileBasenameNoExtension}.out\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": false } ], \"preLaunchTask\": \"build \u0026 run file C++\" }, { \"name\": \"Debug C\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/${fileBasenameNoExtension}.out\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": false } ], \"preLaunchTask\": \"build \u0026 debug file C\" }, { \"name\": \"Debug C++\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/${fileBasenameNoExtension}.out\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": false } ], \"preLaunchTask\": \"build \u0026 debug file C++\" } ] } 註：在分 C/C++ 的配置時可以分開，一個是 gcc 一個是 g++，然而有些人直接全部都是用 g++ 編譯，這樣也可以，只是不能使用 gcc 去編譯 C++。由於肥宅有強迫症，所以分成四個部份。 **注意：這裡肥宅分了四個類型，分別是 Run C Run C++ Debug C Debug C++， 其中每一個 \"program\" （進行調試的程序路徑）參數都是 \"${workspaceFolder}/${fileBasenameNoExtension}.out\"， \"preLaunchTask\" 的值則是對應到 task.json 的 \"label\"，如果兩者對應的名稱出錯在調試時會出現找不到對應名稱的錯誤訊息，要你開啟 launch.json 重新設定。** ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:7:3","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"tasks.json { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build \u0026 debug file C\", \"type\": \"shell\", \"command\": \"gcc\", \"args\": [ \"-g\", \"${file}\", \"-o\", \"${fileBasenameNoExtension}.out\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } }, { \"label\": \"build \u0026 debug file C++\", \"type\": \"shell\", \"command\": \"g++\", \"args\": [ \"-g\", \"${file}\", \"-o\", \"${fileBasenameNoExtension}.out\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } }, { \"label\": \"build \u0026 run file C\", \"type\": \"shell\", \"command\": \"gcc\", \"args\": [ \"${file}\", \"-o\", \"${fileBasenameNoExtension}.out\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } }, { \"label\": \"build \u0026 run file C++\", \"type\": \"shell\", \"command\": \"g++\", \"args\": [ \"${file}\", \"-o\", \"${fileBasenameNoExtension}.out\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } 註：-g 是調試的意思，-o 是輸出的意思。 注意：每個 \"args\" 參數中的 \"${fileBasenameNoExtension}.out\" 要特別注意尾端改成.out。 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:7:4","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"調試畫面 配置完後，你可以在調試欄看到 Run C Run C++ Debug C Debug C++ 選項。 肥宅現在要調試 1.c 這個檔案，可以在代碼中設置斷點，並選擇 Debug C。 設置斷點12.png \" 設置斷點 註：調試快捷鍵 F5 調試13.png \" 調試 左側可以看到變數的值 註：肥宅已在 launch.json 中設定 \"externalConsole\": false，因爲這個設定的意思是使格外彈出個 Konsole，這功能只能在 Windows OS 中改成 true ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:8:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"純手工編譯執行 假設有個檔名叫 1，副檔名可以是 *.c 或 *.cpp ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:9:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"C 編譯標準 C99 gcc -std=c99 1.c -o 1.out 執行 ./1.out ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:9:1","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"C++ 編譯標準 C++11 g++ -std=c++11 1.cpp -o 1.out 執行 ./1.out ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:9:2","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"如果有引入其他自定義的標頭檔之實現檔 編譯時加入參數 e.g. 我有 main.c 且引入自定義的 Circle.h 標頭檔，並且將 Circle.h 標頭檔的實現部份寫在 Circle.cpp 編譯 gcc -std=c99 main.c Circle.cpp -o main.out 執行 ./main.out ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:9:3","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":null,"content":" I am a college student studying at Central South University (CSU) in China. I love programming programs, and I hope that I can find myself by programming. I also like to watch Japanese animation. My favorite music is the theme song of PSYCHO-PASS, 名前のない怪物. My hometown is in Taipei, Taiwan. ","date":"2019-04-19","objectID":"/about/:0:0","tags":null,"title":"關於 Huang Po-Hsun","uri":"/about/"},{"categories":null,"content":"My Skill C/C++, Java, Python, Golang, Js, Front end design, Vue, React, Angular, Qt, Flask, Markdown, LaTeX, ArchLinux, MySQL etc. ","date":"2019-04-19","objectID":"/about/:1:0","tags":null,"title":"關於 Huang Po-Hsun","uri":"/about/"},{"categories":null,"content":"Contact QQ : 2116280484 Telegram : @HuangNO1 E-mail : fh831.cp9gw@gmail.com I don’t often contact with others by WeChat. ","date":"2019-04-19","objectID":"/about/:2:0","tags":null,"title":"關於 Huang Po-Hsun","uri":"/about/"}]